<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Angular 学习</title>
    <link rel="stylesheet" href="../../platform/javascript/syntaxhighlighter/styles/shCoreDefault.css" type="text/css" />

    <link rel="stylesheet" href="../../platform/css/base.css" type="text/css"/>
    <link rel="stylesheet" href="../../platform/css/platform.css" type="text/css"/>
    <link rel="stylesheet" href="../../platform/css/theme/skyblue.css" type="text/css"/>
    <link rel="stylesheet" href="../../platform/css/web.css" type="text/css"/>

    <style>
      body{
        padding:10px;
      }
    </style>

    <script type="text/javascript" src="../../platform/javascript/jquery/jquery.js"></script>

    <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shBrushXml.js"></script>
    <script type="text/javascript" src="../../platform/javascript/syntaxhighlighter/scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="../../platform/javascript/view/init.js"></script>

  </head>
  <body>
    <h3 class="h-web-paragraph-title">目录</h3>
    <ol class="h-web-catalogue">
      <li>
        <a paragraph href="#">Angular 介绍</a>
      </li>
      <li>
        <a paragraph href="#">Angular 例子</a>
      </li>
      <li>
        <a paragraph href="#">AngularJS 构建项目</a>
      </li>
      <li>
        <a paragraph href="#">Angular 注意事项</a>
        <ol class="h-web-catalogue2">
          <li>
            <a href="#">浏览器支持</a>
          </li>
          <li>
            <a href="#">使用 ng 时不要冒然去改变相关 DOM 的结构</a>
          </li>
          <li>
            <a href="#">AngularJS 命名空间</a>
          </li>
        </ol>
      </li>
      <li>
        <a paragraph href="#">Angular 学习笔记</a>
        <ol class="h-web-catalogue2">
          <li>
            <a href="#">数据与模板相关指令</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">显示文本（ng-bind）</a>
              </li>
              <li>
                <a href="#">绑定html内容（ng-bind-html 和 ng-bind-html-unsafe,version1.2.0中已删除该指令）</a>
              </li>
              <li>
                <a href="#">ngNonBindable指令，不绑定angular指令</a>
              </li>
              <li>
                <a href="#">表单输入(ng-model，数据双向绑定)</a>
              </li>
              <li>
                <a href="#">ngList指令</a>
              </li>
              <li>
                <a href="#">ngValue指令</a>
              </li>
              <li>
                <a href="#">ngInit指令</a>
              </li>
              <li>
                <a href="#">ngCloak</a>
              </li>
              <li>
                <a href="#">ngBindTemplate</a>
              </li>
              <li>
                <a href="#">ngInclude</a>
              </li>
              <li>
                <a href="#">ngTransclude</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">Angular中的表达式</a>
          </li>
          <li>
            <a href="#">内容控制指令</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">ngShow和ngHide指令</a>
              </li>
              <li>
                <a href="#">ngIf指令</a>
              </li>
              <li>
                <a href="#">ngSwitch 指令</a>
              </li>
              <li>
                <a href="#">ngRepeat指令</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">节点属性指令</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">ngStyle</a>
              </li>
              <li>
                <a href="#">ngClass</a>
              </li>
              <li>
                <a href="#">ngHref</a>
              </li>
              <li>
                <a href="#">ngChecked ngDisabled ngReadonly ngSelected ngSrc 指令</a>
              </li>
              <li>
                <a href="#">ngOpen</a>
              </li>
              <li>
                <a href="#">ngSrcset</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">事件绑定指令</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">ngBlur</a>
              </li>
              <li>
                <a href="#">ngChange</a>
              </li>
              <li>
                <a href="#">ngClick和ngDblclick</a>
              </li>
              <li>
                <a href="#">ngFocus</a>
              </li>
              <li>
                <a href="#">键盘事件：ngKeydown ngKeypress 和 ngKeyup</a>
              </li>
              <li>
                <a href="#">鼠标事件：ngMousedown ngMouseup ngMousemove ngMouseover ngMouseenter 和 ngMouseleave</a>
              </li>
              <li>
                <a href="#">复制，剪切，粘贴指令 ngCopy ngCut ngPaste </a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">表单元素的用法</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">form</a>
              </li>
              <li>
                <a href="#">input，textarea 的用法</a>
              </li>
              <li>
                <a href="#">input checkbox的用法</a>
              </li>
              <li>
                <a href="#">input radio 的用法</a>
              </li>
              <li>
                <a href="#">select 的用法</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">A 标签和 script 标签</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">A 标签</a>
              </li>
              <li>
                <a href="#">script标签</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">$animate ngAnimate 动画</a>
          </li>
          <li>
            <a href="#">module 和 ngApp 指令</a>
          </li>
          <li>
            <a href="#">Controller 和 ngController指令</a>
          </li>
          <li>
            <a href="#">Services</a>
          </li>
          <li>
            <a href="#">$location service</a>
          </li>
          <li>
            <a href="#">$sce service</a>
          </li>
          <li>
            <a href="#">编译器(complier)</a>
          </li>
          <li>
            <a href="#">使用过滤器格式化数据</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">currency</a>
              </li>
              <li>
                <a href="#">date</a>
              </li>
              <li>
                <a href="#">filter 过滤数组列表</a>
              </li>
              <li>
                <a href="#">json 过滤器</a>
              </li>
              <li>
                <a href="#">limitTo 过滤器</a>
              </li>
              <li>
                <a href="#">lowercase uppercase 过滤器</a>
              </li>
              <li>
                <a href="#">number 过滤器</a>
              </li>
              <li>
                <a href="#">orderBy 排序过滤器</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">Angular global API</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">angular.bind</a>
              </li>
              <li>
                <a href="#">angular.bootstrap</a>
              </li>
              <li>
                <a href="#">angular.copy</a>
              </li>
              <li>
                <a href="#">angular.element</a>
              </li>
              <li>
                <a href="#">angular.forEach</a>
              </li>
              <li>
                <a href="#">angular.injector</a>
              </li>
              <li>
                <a href="#">angular.module</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">路由 ngRoute</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">ngView指令</a>
              </li>
              <li>
                <a href="#">$route service</a>
              </li>
              <li>
                <a href="#">$routeParams service</a>
              </li>
              <li>
                <a href="#">$routeProvider</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">指令(Directives)</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">指令的使用</a>
              </li>
              <li>
                <a href="#">指令的执行过程</a>
              </li>
              <li>
                <a href="#">定义指令相关属性</a>
              </li>
              <li>
                <a href="#">$compile的理解</a>
              </li>
              <li>
                <a href="#">transclude的细节</a>
              </li>
              <li>
                <a href="#">指令处理节点是变量的情况</a>
              </li>
              <li>
                <a href="#">指令中对应节点属性的处理</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">$rootScope 与 $scope</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">Scope Hierarchies</a>
              </li>
              <li>
                <a href="#">Scope Events Propagation</a>
              </li>
              <li>
                <a href="#">$rootScope method</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">Angular 源码分析</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">Angular代码结构与加载过程</a>
              </li>
              <li>
                <a href="#">Angular 几个比较重要的属性和方法</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#">学习angular技巧与方法（最佳实践）</a>
            <ol class="h-web-catalogue3">
              <li>
                <a href="#">在终端控制台调试</a>
              </li>
              <li>
                <a href="#">数据绑定标识标签的修改</a>
              </li>
              <li>
                <a href="#">依赖注入的写法</a>
              </li>
              <li>
                <a href="#">关于登录页面自动保存密码的问题</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a paragraph href="#">Angular 关于浏览器的兼容性</a>
      </li>
    </ol>


    <div class="h-web-paragraph">
      <h3 paragraph>Angular 介绍</h3>
      <div>
        <p>下面是摘自网上的介绍</p>
        <p>Angular 是一个为动态WEB应用设计的结构框架。它能让你使用HTML作为模板语言，通过扩展HTML的语法，让你能更清楚、简洁地构建你的应用组件。
          它的创新点在于，利用 <strong>数据绑定</strong> 和 <strong>依赖注入</strong>，它使你不用再写大量的代码了。
          这些全都是通过浏览器端的Javascript实现，这也使得它能够完美地和任何服务器端技术结合。</p>
        <p>Angular 是为了克服HTML在构建应用上的不足而设计的。HTML是一门很好的为静态文本展示设计的声明式语言，但要构建WEB应用的话它就显得乏力了。
          所以我做了一些工作（你也可以觉得是小花招）来让浏览器做我想要的事。</p>
        <p>angularjs是由Google团队开发的一款非常优秀web前端框架。在当前如此多的web框架下，angularjs能脱颖而出，从架构设计上就高人一等，双向数据绑定，依赖注入，指令，MVC，模板。
          Angular.js创新地把后台技术融入前端开发，扫去jQuery一度的光芒。用angularjs就像写后台代码，更规范，更结构化，更可控。</p>
        <p><a href="http://angularjs.org/">官网</a></p>
        <p><a href="http://www.angularjs.cn/">中文社区</a></p>
        <p><a href="http://angular-ui.github.io/">Angular UI</a></p>
        <p><a href="http://damoqiongqiu.iteye.com/blog/1885371">在Windows上安装Yeoman</a></p>
      </div>
      <h3 paragraph>Angular 例子</h3>
      <div>
        <p><a href="./angular/examples/myExamples/demo1.html">入门例子</a></p>
      </div>
      <h3 paragraph>AngularJS 构建项目</h3>
      <div>
        <p>说到 AngularJS 构建项目，目前主要有三种</p>
        <ul>
          <li>手工项目: 自己建目录，下载类库，写html,js,css，自己实现引用关系</li>
          <li>angular-seed 种子项目: 下载github的angular-seed，在别人的基础之上开发</li>
          <li>Yeoman项目：通过Yeoman下载一个标准Yeoman项目，已经内置了grunt、bower及各种工具包</li>
        </ul>

        <ol>
          <li>
            手工项目
            <p>构建手工项目是我们平时用的最多的一种方式，适用于小型或demo项目，可以参照angularjs一步一步操作就可以了。</p>
          </li>
          <li>
            angular-seed 种子项目
            <p>这个项目是 Angular 一个“种子项目”，构建方法是去github下载项目源代码，基于已有项目结构再做开发。
              这种项目都融入了前人的经验，会以一种比较合理的结构，帮我们构建出项目的原型。适合于有一定规模项目开发，同时更适合 geek 的扩展。</p>
            <p>首先到angular官方下载种子项目，基于node</p>
            <pre>https://github.com/angular/angular-seed</pre>
            <p>关于运行和测试请看上面连接地址，很简单，调用node即可。下载后根据实际需要修改添加自己的代码。</p>
            <p>单元测试(Unit test)：karma + jasmine</p>
            <p>端到端测试(End to End test)：karma + jasmine + webserver</p>
            <p>我们也可以到<a href="http://docs.angularjs.org/tutorial">Angular Tutorial</a> 和 
              <a href="http://docs.angularjs.org/tutorial/step_00">Angular Tutorial</a> 中一步一步来生成种子项目。</p>
          </li>
          <li>
            Yeoman项目
            <p>
              通过标准化的Yeoman可以构建一个企业级应用项目。Yeoman是一个标准化的项目开发工作流工具。Yeoman的安装请参考<a href="#nodejs|nodejs_platform">这篇文章</a>的第三节。
              我们需要的是安装基于angular的构建器
            </p>
            <pre>npm install -g generator-angular</pre>
            <p>然后新建一个项目，在项目下执行以下命令</p>
            <pre>yo angular</pre>
            <p>执行完会下载许多依赖包，构建好的项目文件结构如下</p>
            <ul>
              <li>.tmp：临时目录</li>
              <li>app:开发的源代码的目录</li>
              <li>dist:生成用于发布的项目</li>
              <li>node_modules:nodejs依赖包</li>
              <li>test:测试文件的目录</li>
              <li>.bowerrc:bower属性</li>
              <li>.editooconfig:对开发工具的属性配置</li>
              <li>.gitattributes:git属性的配置</li>
              <li>.gitignore:git管理文件的配置</li>
              <li>.jshintr:JSHint配置</li>
              <li>.travis.yml:travis-ci持续集成的配置</li>
              <li>bower.json:bower依赖管理</li>
              <li>Gruntfile.js:grunt开发过程管理</li>
              <li>karma.conf.js:karma自动化测试</li>
              <li>karma-e2e.conf.js:karma端到端自动化测试</li>
              <li>package.json:项目依赖文件</li>
            </ul>
            <p>我们利用grunt命令来启动项目，详见 Gruntfile.js</p>
          </li>
        </ol>
        <p>参考资料</p>
        <p><a href="http://blog.fens.me/angularjs-yeoman-project/">AngularJS从构建项目开始</a></p>
        <p><a href="http://blog.fens.me/series-angular/">AngularJS体验式编程系列文章</a></p>
        <p><a href="https://github.com/bsspirit">项目模板参考</a></p>
      </div>
      <h3 paragraph>Angular 注意事项</h3>
      <div>
        <h4>浏览器支持</h4>
        <p>
          对 IE 方面，它兼容 IE8 及以上的版本。
        </p>
        <h4>使用 ng 时不要冒然去改变相关 DOM 的结构</h4>
        <h4>AngularJS 命名空间</h4>
        <p>为了防止意外的命名冲突， AngularJS为可能冲突的对象名加以前缀"$"。所以请不要在你自己的代码里用"$"做前缀，以免和AngularJS代码发生冲突。
          所以以$为前缀的对象都是Angular本身定义的对象。
        </p>
      </div>
      <h3 paragraph>Angular 学习笔记</h3>
      <div>
        <h4>数据与模板相关指令</h4>
        <h5>显示文本（ng-bind）</h5>
        <p>我们可以使用ng-bind指令在UI的任何地方显示和更新文本，也可以使用双花括号形式来绑定文本。</p>
        <p>双花括号形式例子：</p>
        <pre>    &lt;p&gt;{{greeting}}&lt;/p&gt;  </pre>
        <p>使用ng-bind基于属性的指令例子：</p>
        <pre>    &lt;p ng-bind="greeting"&gt;&lt;p&gt;  </pre>
        <p>这两者的输出是等价的。 如果模型中的变量greeting设置为"Hi, there", Angular将生成这样的HTML：</p>
        <pre>    &lt;p&gt;Hi, there&lt;/p&gt;  </pre>
        <p>浏览器将显示"Hi, There"。</p>
        <p>一般情况下我们使用双花括号的形式，这样读起来更加方便自然。但有时页面在开始的时候加载模板内容，这样就会先显示双花括号，等Angular解析完后再显示实际的值，
          这会造成用户体验差，这时我们就可以用指令的方式，使之开始什么都不显示。当然还有一种方式就是开始的时候隐藏模板内容，等Angular解析完后再动态显示（可以利用jQuery来完成操作）。
        </p>
        <p>这里需要注意的是：{{expression}}只作为显示值来用，而不能作为字符串和html拼接 。听起来不太明白，还是看例子吧，以下用法是错误的（在1.0.8版本中测试）。</p>
        <pre>
          &lt;input {{expression}} /&gt;
        </pre>
        <p>正确的用法应该是</p>
        <pre>
          &lt;input attribute="{{expression}}" /&gt;
        </pre>
        <p>以下是一个完整的例子</p>
        <pre>
 &lt;!DOCTYPE html&gt;
 &lt;html ng-app="ngBindDemo"&gt;
   &lt;head&gt;
     &lt;meta charset="utf-8"&gt;
     &lt;title&gt;ng-bind demo &lt;/title&gt;
   &lt;/head&gt;
   &lt;body ng-controller="ngBindDemoController"&gt;
     &lt;input ng-model='greeting.text' /&gt;
     &lt;p&gt;{{greeting.text}}, World &lt;/p&gt;
     &lt;p&gt;以下用法是错误的 &lt;/p&gt;
     &lt;input name="wrong" style="border: 1px solid #ED2754;" {{attribute}}/&gt;
     &lt;script type="text/javascript" src="../../angular.js"&gt; &lt;/script&gt;
     &lt;script type="text/javascript"&gt;
        //创建一个app，并在该app下创建一个controller
        angular.module('ngBindDemo', []).controller('ngBindDemoController', ['$scope', function($scope) {
            $scope.greeting = {
              text: 'Hello'
            };
          }]);
     &lt;/script&gt;
   &lt;/body&gt;
 &lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-bind-demo.html">运行效果</a></p>

        <h5>绑定html内容（ng-bind-html 和 ng-bind-html-unsafe,version1.2.0中已删除该指令）</h5>
        <p>angular提供了这两个指令通过innerHTML来给指定的元素设置内容。ng-bind-html会调用angular提供的  <a href="http://code.angularjs.org/api/ngSanitize.$sanitize">$sanitize</a>（$sanitize(html);）过滤后再赋给innerHTML，而 ng-bind-html-unsafe不会处理直接赋给innerHTML，当确保提供的html片段是安全的，我们可以用ng-bind-html-unsafe。</p>
        <p class="h-web-font-red">注意：使用ng-bind-html指令时，需要引入文件angular-sanitize.js，并且要把 "ngSanitize" 加入到相应的module中。</p>
        <pre>
   angular.module('app', ['ngSanitize']);
        </pre>
        <p>下面是官方提供的例子（有修改）：</p>
        <pre>     
&lt;!doctype html&gt;
&lt;html ng-app="ngBindHtmlDemoApp"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-bind-html and ng-bind-html-unsafe demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div ng-controller="ngBindHtmlDemoCtrl"&gt;
      Snippet: &lt;textarea ng-model="snippet" cols="60" rows="3"&gt;&lt;/textarea&gt;
      &lt;table style="border: 1px solid #005B73;"&gt;
        &lt;tr&gt;
          &lt;td&gt;Filter&lt;/td&gt;
          &lt;td&gt;Source&lt;/td&gt;
          &lt;td&gt;Rendered&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr id="html-filter"&gt;
          &lt;td&gt;html filter&lt;/td&gt;
          &lt;td&gt;
            &lt;pre&gt;&lt;div ng-bind-html="snippet"&gt;&lt;br/&gt;&lt;/div&gt;&lt;/pre&gt;
          &lt;/td&gt;
          &lt;td&gt;
            &lt;div ng-bind-html="snippet"&gt;&lt;/div&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr id="html-filter"&gt;
          &lt;td&gt;AngularJS Google Group提供的利用指令实现同样的过滤效果&lt;/td&gt;
          &lt;td&gt;
            &lt;pre&gt;&lt;div html-title="snippet" &gt;&lt;br/&gt;&lt;/div&gt;&lt;/pre&gt;
          &lt;/td&gt;
          &lt;td&gt;
            &lt;div  html-title="{{snippet}}"&gt;&lt;/div&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr id="escaped-html"&gt;
          &lt;td&gt;no filter&lt;/td&gt;
          &lt;td&gt;&lt;pre&gt;&lt;div ng-bind="snippet"&gt;&lt;br/&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td&gt;&lt;div ng-bind="snippet"&gt;&lt;/div&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr id="html-unsafe-filter"&gt;
          &lt;td&gt;unsafe html filter&lt;/td&gt;
          &lt;td&gt;&lt;pre&gt;&lt;div ng-bind-html-unsafe="snippet"&gt;&lt;br/&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;
          &lt;td&gt;&lt;div ng-bind-html-unsafe="snippet"&gt;&lt;/div&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/div&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../../angular-sanitize.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
            //创建一个app，并在该app下创建一个controller
            angular.module('ngBindHtmlDemoApp', ['ngSanitize']).controller('ngBindHtmlDemoCtrl', ['$scope', function($scope) {
                $scope.snippet =
                        '&lt;p style="color:blue"&gt;an html\n' +
                        '&lt;em onmouseover="this.textContent=\'PWN3D!\'" onmouseout="this.textContent=\'the mouse over\'"&gt;the mouse over&lt;/em&gt;\n' +
                        'snippet&lt;/p&gt;';
              }]).directive('htmlTitle', function($sanitize) {
              return {
                restrict: 'A',
                link: function(scope, element, attrs) {
                  attrs.$observe('htmlTitle', function(title) {
                    // convert &value; to HTML
                    var html = angular.element('&lt;div&gt;&lt;/div&gt;').html($sanitize(title)).text();
                    element.attr('title', html);
                    element.html(html);
                  });
                }
              };
            });
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>  

        <p><a href="./angular/examples/myExamples/ng-bind-html-demo.html">运行效果</a></p>

        <h5>ngNonBindable指令，不绑定angular指令</h5>
        <p>对于部分html片段，虽然代码中有angular相关指令，但我们不想让这些指令执行，这是用ngNonBindable指令就能解决</p>
        <pre>
          <div ng-non-bindable>Ignored: {{1 + 2}}</div>
          会解析为
          Ignored: {{1 + 2}}
        </pre>
        <p><a href="./angular/examples/myExamples/ng-non-bindable-demo.html">点击查看例子</a></p>

        <h5>表单输入(ng-model，数据双向绑定)</h5>
        <p>在Angular中处理表单元素是很简单的，只需使用ng-model属性绑定到你的模型属性元素上即可。
          ng-model适用于所有标准的表单元素, 例如文本输入框, 单选按钮, 复选框等等。我们可以像这样绑定一个复选框：</p>
        <pre>    &lt;form controller="SomeController"&gt;
          &lt;input type="checkbox" ng-model="youCheckedIt"&gt;
    &lt;/form&gt;  </pre>
        <p>这意味着：</p>
        <ol>
          <li>当用户选择复选框, SomeController的$scope中一个名为youCheckedIt的属性将变成true。取消选择时使youCheckedIt变成false。</li>
          <li>如果你在SomeController中设置$scope.youCheckedIt为true， 这个复选框在UI中会被自动选择。设置它为false则取消选择。</li>
        </ol>
        <p>我们也可以在form表单上注册一些事件，比如change，click等，例如：</p>
        <pre>&lt;form ng-controller="StartUpController"&gt;
      Starting: &lt;input ng-change="computeNeeded()" ng-model="funding.startingEstimate"&gt;
      Recommendation: {{funding.needed}}
&lt;/form&gt;
function StartUpController($scope){
      $scope.funding = { startingEstimate: 0 };
      $scope.computeNeeded = function(){
        $scope.needed = $scope.startingEstimate * 10;
    };
}</pre>

        <p>以下是一个完整的例子：</p>
        <pre>
&lt;!DOCTYPE html&gt;
&lt;html ng-app="ngModelDemo"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-model demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body ng-controller="ngModelDemoController"&gt;
    &lt;form&gt;
      &lt;div style="border: 1px solid #0060BF;padding: 10px; width: 300px;"&gt;
        Starting: &lt;input ng-change="computeNeeded()" ng-model="funding.startingEstimate"&gt;
        Recommendation: {{funding.needed}}
      &lt;/div&gt;
      &lt;div style="border: 1px solid #007788;margin-top: 10px;padding: 10px; width: 300px;"&gt;
        多选框： &lt;input type="checkbox" ng-model="youCheckedIt" /&gt;
        &lt;br /&gt;
        checkbox选择情况：{{youCheckedIt}}
      &lt;/div&gt;
    &lt;/form&gt;

    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
      //创建一个app，并在该app下创建一个controller
      angular.module('ngModelDemo', []).controller('ngModelDemoController', ['$scope', function($scope) {
          $scope.funding = {startingEstimate: 0};
          $scope.computeNeeded = function() {
            $scope.funding.needed = $scope.funding.startingEstimate * 10;
          };
          $scope.youCheckedIt = false;
        }]);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-model-demo.html">运行效果</a></p>

        <h5>ngList指令</h5>
        <p>该指令能把array转换为字符串，默认字符串的拼接用逗号（,），该指令类似于array的join方法</p>

        <p>注意：<span class="h-web-font-red">该指令只能和ngModel配合使用，也就是说只能用在input等表单元素上。</span></p>
        <p>对于嵌套数组也会解析的，只是内层解析后 ,后面没有空格，不知道这是不是angular的一个bug。还有对于数组中的对象元素，会调用toString()方法</p>
        <pre>
&lt;!DOCTYPE html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-list demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body &gt;
    &lt;form name="myForm" ng-controller="Ctrl"&gt;
      &lt;div&gt;
        List: &lt;input name="namesInput" ng-model="names" ng-list /&gt;
      &lt;/div&gt;
      &lt;div style="margin-top:10px;"&gt;
        List(如果ng-model的值为非数组则返回空): &lt;input name="namesInput2" ng-model="namesStr" ng-list /&gt;
      &lt;/div&gt;
      &lt;div style="margin-top:10px;"&gt;
        List(嵌套数组): &lt;input name="namesInput3" ng-model="nestedArray" ng-list size="100" /&gt;
      &lt;/div&gt;

      &lt;div style="margin-top:10px;"&gt;
        List(没有设置ng-model会报错): &lt;input name="namesInput4" ng-list /&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
          function Ctrl($scope) {
            $scope.names = ['igor', 'misko', 'vojta'];
            $scope.namesStr = 'string';
            $scope.nestedArray = [['igor', 'misko', new Date(), ['inner1', 'inner2'],{}], 'igor', 'misko', 'vojta'];
          }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;          
        </pre>

        <p><a href="./angular/examples/myExamples/ng-list-demo.html">运行效果</a></p>

        <h5>ngValue指令</h5>
        <p>该指令主要用来设置input，select初始值，该指令与ng-model和ng-repeat结合使用</p>
        <p><a href="./angular/examples/myExamples/ng-value-demo.html">点击查看例子</a></p>

        <h5>ngInit指令</h5>
        <p>该指令用来给变量赋初始值，理解起来比较简单，直接看例子吧。</p>
        <p><a href="./angular/examples/myExamples/ng-init-demo.html">点击查看例子</a></p>


        <h5>ngCloak</h5>
        <p>该指令是介于ngBind和ngBindHtml之间的，如果我们用{{}}来处理页面显示数据，就会在页面加载的初始显示没有编译的{{}}，angular编译后显示相应的值，这样用户体验效果差些。
          为了避免这种不好的体验效果，angular提供了一个指令ngCloak，该指令是用class来控制的，当没有编译前，如果包含了ngCloak指令时，该元素（包括他的子节点）隐藏，编译后删除class来显示。
          用到的class在angular.js中已集成。
        </p>
        <pre>
          [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
            display: none !important;
          }
        </pre>
        <p>由于ie7中不支持[ng\:cloak] selector。我们需要为其设置class，看下面的例子</p>
        <pre>
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-cloak demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="template1" ng-cloak&gt;{{ 'hello'}}&lt;/div&gt;
    &lt;div id="template2" ng-cloak class="ng-cloak"&gt;{{ 'hello IE7'}}&lt;/div&gt;
    
    &lt;div&gt;{{ '没有用ngCloak指令显示效果'}}&lt;/div&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
      setTimeout(function() {
        angular.bootstrap(document.documentElement);
      }, 2000);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-cloak-demo.html">运行效果</a></p>

        <h5>ngBindTemplate</h5>
        <p>
          相比ngBind，该指令提供了更灵活的赋值，可以设置{{expressions}}，而ngBind是不可以的。另外，该指令只会把ngBindTemplate中设置的值当文本来处理，而不会当成html来处理。
          看下面的例子
        </p>
        <pre>
&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-bind-template demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div ng-controller="Ctrl"&gt;
      Salutation: &lt;input type="text" ng-model="salutation"&gt;&lt;br&gt;
      Name: &lt;input type="text" ng-model="name"&gt;&lt;br&gt;
      &lt;pre ng-bind-template="{{salutation}} ' , ' &lt;span&gt;&lt;/span&gt;{{name}}! 你好"&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;span ng-bind-template="nihao"&gt;&lt;/span&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
        function Ctrl($scope) {
          $scope.salutation = 'Hello';
          $scope.name = 'World';
        }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;          
        </pre>
        <p><a href="./angular/examples/myExamples/ng-bind-template-demo.html">运行效果</a></p>

        <h5>ngInclude</h5>
        <p>
          ngInclude指令可以包含模板文件（外部定义的文件，内部用&lt;script type="text/ng-template" id="tpl"&gt;content, {{ 1 + 1}}&lt;/script&gt;）。该指令的用法为：
        </p>
        <pre>
    as element:
    <ng-include
    src="{string}"
    [onload="{string}"]
    [autoscroll="{string}"]>
    </ng-include>

    as attribute
    <ANY ng-include="{string}"
    [onload="{string}"]
    [autoscroll="{string}"]>
    ...
    </ANY>

    as class
    <ANY class="ng-include: {string}; [onload: {string};] [autoscroll: {string};]">
    ...
    </ANY>
        </pre>
        <p>该指令可以结合animate来实现动画效果。</p>
        <p>
          注意：<span class="h-web-font-red">1.This directive creates new scope.<br/> 
            2.This directive executes at priority level 400. <br/>
            3.还需注意安全问题，ngInclude won't work for cross-domain requests on all browsers and for file:// access on some browsers.<br/>
            4.模板中不支持script，但支持style。</span></p>

        <p><a href="./angular/examples/myExamples/ng-include-demo.html">点击查看实例</a></p>

        <h5>ngTransclude</h5>
        <p>
          该指令用在父指令的模板中，angular编译时，用父指令中的内容替换ng-transclude。不能像其他指令直接使用。
        </p>
        <p><a href="./angular/examples/myExamples/ng-transclude-demo.html">点击查看实例</a></p>

        <h4>Angular中的表达式</h4>
        <p>表达式可以使我们在处理模板，程序逻辑和数据变得更加灵活方便。</p>
        <p>表达式可以处理简单的数学运算(+, -, /, *, %), 进行比较(==, !=,&gt;, &lt;,&gt;=, &lt;=), 执行布尔逻辑运算(&amp;&amp;, ||, !)以及按位运算(^, &amp;, |)，字符串连接(+)，引用数据和对象表示法([], {}, …)。
          还可以调用暴露在控制器$scope对象上的属性和方法。</p>
        <p>下面都是有效表达式的例子:</p>
        <pre>
    &lt;div ng-controller="SomeController"&gt;
          &lt;div&gt;{{recompute() / 10}}&lt;div&gt;
          &lt;ul ng-repeat="thing in things"&gt;
              &lt;li ng-class="{highlight: $index % 4&gt;= threshold($index)}"&gt;
                  {{otherFunction($index)}}
              &lt;/li&gt;
          &lt;/ul&gt;
      &lt;/div&gt;
        </pre>
        <p>这里的第一个表达式recompute() / 10是有效的，是用函数recompute()返回的值除以10，但我们应该避免这样使用。保持视图和控制器之间的职责分离可以确保它们容易理解和测试。</p>
        <p>Angular提供的表达式可以做很多事情, 它们是由Angular自定义的解释器计算，并不使用JavaScript的eval()执行, 因为eval()效率低而且有相当多的限制。</p>
        <p>Angular自带的自定义解释器中不支持循环结构(for, while等), 流程控制语句(if-else, throw)或者改变数据的运算符(++, --)。 当你需要使用这些类型的运算时, 你应该在你的控制器中使用指令进行处理。</p>
        <p>尽管表达式在很多方面比JavaScript更加严格，但它们对undefined和null并不是很严格(更宽松)。模板只是简单的渲染一些东西, 并不会抛出一个错误。
          这样我们就能安全的使用模型而没有限制, 并且用得到的数据填充到用户界面中。</p>

        <h4>内容控制指令</h4>
        <h5>ngShow和ngHide指令</h5>
        <p>
          用来显示或隐藏指令包含的内容，这里需要注意的是<span class="h-web-font-red">1.0.8版本是通过style="display:none;"来控制隐藏和显示的，而最新版本1.2.0中使用ng-hide class样式来控制的。
            为了在angular编译前，不显示该元素，对于1.0.8版本，我们可以为该元素设置style="display:none;"；而对于1.2.0版本我们可以提前设置ng-hide class样式</span>。如下代码： </p>
        <pre>
          <span ng-hide="hideContent" style="display:none;">{{ '隐藏的内容（1.0.8）'}}</span>
          <span ng-hide="hideContent" class="ng-hide">{{  '隐藏的内容（1.2.0）'}}</span>
        </pre>
        <p>这样在编译前，该元素也会隐藏，编译后如果hideContent值为true也会隐藏，保存编译前后显示一致，尤其是对于加载慢的页面来说，这样设置，用户体验效果会更好些。</p>
        <p>另外同时设置了ng-show 和 ng-hide , 如果ng-show的值改变了，就按ng-show处理。同样，如果ng-hide的值改变了，就按ng-hide处理</p>
        <p><a href="./angular/examples/myExamples/ng-show-or-ng-hide-demo.html">点击查看实例</a></p>

        <h5>ngIf指令</h5>
        <p>该指令根据值为true或false来创建或删除指令包含的内容，该指令不同于ngShow和ngHide，不是隐藏或显示指令中的内容，每次都会重新创建或删除内容</p>

        <p><a href="./angular/examples/myExamples/ng-if-demo.html">点击查看实例</a></p>

        <h5>ngSwitch 指令</h5>
        <p>ngSwitch 指令会根据不同的条件显示不同的内容，需要跟ngSwitchWhen or ngSwitchDefault 结合使用</p>
        <p>注意：<span class="h-web-font-red">1.This directive creates new scope. 2.This directive executes at priority level 800.</span>
        </p>
        <p>所以，我们创建时，里面的ng-model最好用父节点设置的变量</p>
        <pre>
   ng-model应该采用父scope中定义的变量

   <div ng-init="a = 2">
    <ul ng-switch on="a">
      <li ng-switch-when="1"><input type="radio" value="1" ng-model="geoAddress.radio" /></li>
      <li ng-switch-when="2"><input type="radio" value="2" ng-model="geoAddress.radio" /></li>
      <li ng-switch-default><input type="radio" value="3" ng-model="geoAddress.radio" /></li>
    </ul>
  </div>
        </pre>
        <p><a href="./angular/examples/myExamples/ng-switch-demo.html">点击查看实例</a></p>

        <h5>ngRepeat指令</h5>
        <p>ngRepeat 指令 会实例化一个模板，每个迭代item会用该模板创建内容并生成自己的scope，该template scope提供了以下属性</p>
        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Type</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>$index</td>
              <td>number</td>
              <td>iterator offset of the repeated element (0..length-1)</td>
            </tr>
            <tr>
              <td>$first</td>
              <td>boolean</td>
              <td>true if the repeated element is first in the iterator.</td>
            </tr>
            <tr>
              <td>$middle</td>
              <td>boolean</td>
              <td>true if the repeated element is between the first and last in the iterator.</td>
            </tr>
            <tr>
              <td>$last</td>
              <td>boolean</td>
              <td>true if the repeated element is last in the iterator.</td>
            </tr>
            <tr>
              <td>$even</td>
              <td>boolean</td>
              <td>true if the iterator position $index is even (otherwise false).</td>
            </tr>
            <tr>
              <td>$odd</td>
              <td>boolean</td>
              <td>true if the iterator position $index is odd (otherwise false).</td>
            </tr>
          </tbody>
        </table>

        <p>在最新版本中增加了两个指令 ng-repeat-start 和 ng-repeat-end。这两个指令处理循环会更加方便，我们可以这样使用他</p>
        <pre>
    <header ng-repeat-start="item in items">
      Header {{ item}}
    </header>
      <div class="body">
      Body {{ item}}
      </div>
    <footer ng-repeat-end>
      Footer {{ item}}
    </footer>
        </pre>
        <p>如果为items设置了 ['A','B'] 后，运行结果为：</p>
        <pre>
    <header>
    Header A
    </header>
    <div class="body">
    Body A
    </div>
    <footer>
    Footer A
    </footer>
    <header>
    Header B
    </header>
    <div class="body">
    Body B
    </div>
    <footer>
    Footer B
    </footer>
        </pre>

        <p>该指令支持的动画 Animations 有</p>
        <ul>
          <li>enter - when a new item is added to the list or when an item is revealed after a filter</li>
          <li>leave - when an item is removed from the list or when an item is filtered out</li>
          <li>move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered</li>
        </ul>

        <p>ngRepeat包含的表达式，除了支持array，还支持json，比如(name, age) in {'adam':10, 'amalie':12}，
          还可以用这样的表达式：variable in expression track by tracking_expression ，by后面可以是function，也可以是变量，例如：
          item in items track by $id(item)，item in items track by item.id。这里需要注意的是，<span class="h-web-font-red">by后面的表达式表示记录中该属性的值不能重复，否则会报错，这样就可以确保记录的唯一性</span>。 </p>

        <p><a href="./angular/examples/myExamples/ng-repeat-demo.html">点击查看实例</a></p>

        <h4>节点属性指令</h4>
        <h5>ngStyle</h5>
        <p>用来设置样式，该指令比原生的style使用起来更加灵活，其表达式值是 key-value 的json值</p>
        <pre>
          <span ng-style="{color:'red','font-size':'14px'}">Sample Text</span>
        </pre>

        <p>我们需要注意的是，<span class="h-web-font-red">1.ng-style会覆盖style中设置同名的样式值，而不会覆盖不同命的样式值。<br />
            &lt;span style="font-weight: bold;color: red;" ng-style="{color: 'blue'}"&gt;Sample Text&lt;/span&gt;<br />
            color会被覆盖，但font-weight不会消失

            2.在IE中如果给原生的style动态的赋值，是不起作用的</span>。例如：
          &lt;span ng-init="customStyle = 'width: 100px;font-size: 20px;border: 1px solid #004080'"&gt; 初始化值 &lt;/span&gt;
          &lt;span style="{{customStyle}}"&gt;原生的style&lt;/span&gt;</p>

        <p><a href="./angular/examples/myExamples/ng-style-demo.html">点击查看实例</a></p>

        <h5>ngClass</h5>
        <p>该指令对应的表达式值支持以下三种</p>
        <ul>
          <li>一个使用空格分割类名的字符串</li>
          <li>一个类名数组 array </li>
          <li>类名到布尔值的映射 map</li>
        </ul>
        <pre>
          <p ng-class="{strike: strike, bold: bold, red: red}">Map Syntax Example</p>
          <p ng-class=" 'bold strike red'">Using String Syntax</p>
          <p ng-class="['bold', 'strike', 'red']">Using Array Syntax</p>
        </pre>
        <p>该指令支持的动画效果有 animate</p>
        <ul>
          <li>add - happens just before the class is applied to the element</li>
          <li>remove - happens just before the class is removed from the element</li>
        </ul>
        <p>该指令不会重复添加之前设置的class</p>

        <p>与该指令对应的还有两个 ngClassEven 和 ngClassOdd ，这两个指令与ngRepeat结合使用，来设置单数行和双数行的样式</p>
        <pre>
  <ul ng-init="l = [1, 2, 3, 4]">
    <li ng-class-odd="'odd'" ng-class-even="'even'" ng-repeat="m in l">{{m}}</li>
  </ul>
        </pre>
        <p><a href="./angular/examples/myExamples/ng-class-demo.html">点击查看实例</a></p>

        <h5>ngHref</h5>
        <p>该指令主要解决当angular还没有编译完成时，如果用户单击了 a link可能会产生错误</p>
        <p>The wrong way to write it:</p>
        <pre><a href="http://www.gravatar.com/avatar/{{hash}}"/></pre>

        <p>The correct way to write it:</p>
        <pre><a ng-href="http://www.gravatar.com/avatar/{{hash}}"/></pre>
        <p><a href="./angular/examples/myExamples/ng-href-demo.html">点击查看实例</a></p>

        <h5>ngChecked ngDisabled ngReadonly ngSelected ngSrc 指令</h5>
        <p>这几个指令都是用来设置属性的，用法与ngHref类似，这里主要讲一下注意事项</p>
        <ul>
          <li><em>ng-checked</em> 选中状态
            <p>原生的checked，在input表单标签中只需设置该属性，而不论他的值是什么，都是选择状态。ng-checked解决了这个问题，可以根据设置的值来判断选中状态，
              例子：&lt;input type="checkbox" ng-checked="master"&gt; 。会根据master的值判断是否选中。
            </p>
          </li>
          <li><em>ng-disabled</em> 禁用状态
            <p>The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs: </p>
            <pre>
   <div ng-init="scope = { isDisabled: false }">
    <button disabled="{{scope.isDisabled}}">Disabled</button>
   </div>
            </pre>
            <p>ng-disabled解决了这个问题</p>
          </li>
          <li><em>ng-readonly</em> 只读状态
            <p>
              与 checked属性解决的问题一样
            </p>
          </li>
          <li><em>ng-selected</em> 被选择状态
            <p>
              与 checked属性解决的问题一样
          </li>
          <li><em>ng-src</em> src属性
            <p>当数据绑定给一个&lt;img&gt;标签时, 在src属性中使用{{ }}处理路径将无法正常工作。因为在浏览器中图片与其他内容是并行加载的, 所以Angular无法拦截数据绑定的请求。</p>
            <p>对于&lt;img&gt;而言最明显的语法错误就是：</p>
            <pre>    &lt;img src="/images/cats/{{favoriteCat}}"&gt;  </pre>
            <p>正确的，我们应该使用ng-src属性并像下面这样编写模板：</p>
            <pre>    &lt;img ng-src="/images/cats/{{favoriteCat}}"&gt;  </pre>
          </li>
        </ul>

        <h5>ngOpen</h5>
        <p>待研究</p>

        <h5>ngSrcset</h5>
        <p>待研究</p>

        <h4>事件绑定指令</h4>
        <h5>ngBlur</h5>
        <p>
          这个指令是新加入的，1.0.8版本中没有该指令，需自己注册事件。该指令可用在window, input, select, textarea, a上。对于老版本可以自己创建指令。
          可以参考该 <a href="http://jsfiddle.net/tidelipop/wyjdT/">例子</a>。 待研究。
        </p>
        <h5>ngChange</h5>
        <p>该指令必须要有ng-model，否则会报错</p>
        <p><a href="./angular/examples/myExamples/ng-change-demo.html">点击查看实例</a></p>
        <h5>ngClick和ngDblclick</h5>
        <p>这两个指令好理解，这里不多说。</p>

        <h5>ngFocus</h5>
        <p>该指令同 ngBlur</p>

        <h5>键盘事件：ngKeydown ngKeypress 和 ngKeyup</h5>
        <p>对应原生的事件keydown keypress 和keyup，键盘被按下，按键 和键盘抬起的事件</p>

        <h5>鼠标事件：ngMousedown ngMouseup ngMousemove ngMouseover ngMouseenter 和 ngMouseleave</h5>
        <p>这是一系列鼠标事件，对于浏览器不支持的mouseenter和mouseleave，angular实现了他，关于实现可以参考jQuery实现代码，现在常用js框架都会实现这两个事件。</p>

        <h5>复制，剪切，粘贴指令 ngCopy ngCut ngPaste </h5>
        <p>这三个指令跟ngBlur类似，只能用在以下标签上 window, input, select, textarea, a</p>












        <h4>表单元素的用法</h4>

        <h5>form</h5>
        <p>angular 对form表单提供了校验，form表单中的元素是否被修改，click和submit事件处理的规则</p>
        <p><strong>CSS classes</strong></p>
        <ul>
          <li>ng-valid Is set if the form is valid.</li>
          <li>ng-invalid Is set if the form is invalid.</li>
          <li>ng-pristine Is set if the form is pristine.</li>
          <li>ng-dirty Is set if the form is dirty.</li>
        </ul>
        <p>ng-pristine，在js中可以这样使用$scope.formName.$pristine，如果表单中有值改变，该值会改变。利用该属性可以处理判断用户是否改变了当前页面中的值，
          也可以利用该属性实现以下功能，首先把提交按钮置为disabled，当有值变化时，去掉disabled。ng-dirty 实现的功能正好相反</p>
        <p>关于click和submit事件的处理，angular定义了以下规则</p>
        <p>To prevent double execution of the handler, use only one of the <a href="http://docs.angularjs.org/api/ng.directive:ngSubmit">ngSubmit</a> or <a href="http://docs.angularjs.org/api/ng.directive:ngClick">ngClick</a> directives.  This is because of the following form submission rules in the HTML specification:</p>
        <ul>
          <li>If a form has only one input field then hitting enter in this field triggers form submit  (ngSubmit)</li>
          <li>if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter  doesn't trigger submit</li>
          <li>if a form has one or more input fields and one or more buttons or input[type=submit] then  hitting enter in any of the input fields will trigger the click handler on the <em>first</em> button or  input[type=submit] (ngClick) <em>and</em> a submit handler on the enclosing form (ngSubmit)</li>
        </ul>
        <p> </p>
        <p>以下是一个完整的例子</p>
        <pre>
&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;ng-form demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form name="myForm" ng-submit="myFormSubmit();"&gt;
      userType: &lt;input name="input" ng-model="userType" required&gt;
      &lt;span class="error" ng-show="myForm.input.$error.required"&gt;Required!&lt;/span&gt;&lt;br&gt;
      &lt;tt&gt;userType = {{userType}}&lt;/tt&gt;&lt;br&gt;
      &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br&gt;
      &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br&gt;
      &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;
      &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;

      username: &lt;input name="input" ng-model="username"&gt;&lt;br&gt;
      &lt;button type="submit" ng-disabled="myForm.$pristine" &gt;提交&lt;/button&gt;
      &lt;button type="button" ng-disabled="myForm.$dirty" &gt;取消&lt;/button&gt;
    &lt;/form&gt;

    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
        function Ctrl($scope) {
          $scope.userType = 'guest';
          $scope.myFormSubmit = function() {
            console.info('submit');
          };
        }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-form.html">运行效果</a></p>

        <h5>input，textarea 的用法</h5>
        <p>这两个元素的用法相对简单，主要有以下指令，详细用法见官网Api。其中angular提供的校验很好，但需要手工书写错误信息，本人建议还是使用jquery validate比较方便。</p>
        <pre>
        &lt;input
    ng-model="{string}"
    [name="{string}"]
    [required]
    [ng-required="{boolean}"]
    [ng-minlength="{number}"]
    [ng-maxlength="{number}"]
    [ng-pattern="{string}"]
    [ng-change="{string}"]&gt;
    &lt;/input&gt;
        </pre>

        <h5>input checkbox的用法</h5>
        <p>checkbox用法比较简单，可以结合ng-true-value 和ng-false-value 指令来设置选中和没选中的值，
          如果没有用这两个指令的话，默认选中为true，反之为false
        </p>
        <pre>
    <form name="myForm" ng-controller="Ctrl">
      Value1: <input type="checkbox" ng-model="value1"> <br/>
      Value2: <input type="checkbox" ng-model="value2"
      ng-true-value="YES" ng-false-value="NO"> <br/>
      <tt>value1 = {{value1}}</tt><br/>
      <tt>value2 = {{value2}}</tt><br/>
    </form>
        </pre>
        <p>对于一组checkbox来说，我们可以利用ng-repeat指令来处理</p>
        <pre>
      Checkbox group: 
      &lt;div ng-repeat="field in checkboxFields"&gt;
        {{field.name}} : &lt;input type="checkbox" ng-model="field.value"&gt; 
      &lt;/div&gt;

      &lt;hr/&gt;
      &lt;p&gt;
        设置结果：
      &lt;/p&gt;
      &lt;div ng-repeat="field in checkboxFields"&gt;
        &lt;tt&gt;{{field.name}} = {{field.value}}&lt;/tt&gt;
      &lt;/div&gt;
        </pre>

        <p>以下是一个完整的例子</p>
        <pre>
&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;checkbox demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form name="myForm" ng-controller="Ctrl"&gt;
      Value1: &lt;input type="checkbox" ng-model="value1"&gt; &lt;br/&gt;
      Value2: &lt;input type="checkbox" ng-model="value2"
                     ng-true-value="YES" ng-false-value="NO"&gt; &lt;br/&gt;
      &lt;tt&gt;value1 = {{value1}}&lt;/tt&gt;&lt;br/&gt;
      &lt;tt&gt;value2 = {{value2}}&lt;/tt&gt;&lt;br/&gt;&lt;br/&gt;

      对于一组checkbox来说，可以利用循环来实现&lt;br/&gt;
      Checkbox group: &lt;br/&gt;
      &lt;div ng-repeat="field in checkboxFields"&gt;
        {{field.name}} : &lt;input type="checkbox" ng-model="field.value"&gt; 
      &lt;/div&gt;

      &lt;hr/&gt;
      &lt;p&gt;
        设置结果：
      &lt;/p&gt;
      &lt;div ng-repeat="field in checkboxFields"&gt;
        &lt;tt&gt;{{field.name}} = {{field.value}}&lt;/tt&gt;&lt;br/&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
          function Ctrl($scope) {
            $scope.checkboxFields = [{
                name: '北京',
                value: false
              }, {
                name: '天津',
                value: true
              }, {
                name: '上海',
                value: false
              }];
            $scope.value1 = true;
            $scope.value2 = 'YES';
          }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-checkbox-demo.html">运行效果</a></p>

        <h5>input radio 的用法</h5>
        <p>radio处理起来比checkbox更加方便，对于一组radio来说，他只有一个值，他们共用一个ng-model，但每个radio的值不同。看下面的例子</p>
        <pre>
&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;radio demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form name="myForm" ng-controller="Ctrl"&gt;
      &lt;input type="radio" ng-model="color" value="red"&gt; Red &lt;br/&gt;
      &lt;input type="radio" ng-model="color" value="green"&gt; Green &lt;br/&gt;
      &lt;input type="radio" ng-model="color" value="blue"&gt; Blue &lt;br/&gt;
      &lt;tt&gt;color = {{color}}&lt;/tt&gt;&lt;br/&gt;
    &lt;/form&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        function Ctrl($scope) {
          $scope.color = 'blue';
        }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/ng-radio-demo.html">运行效果</a></p>

        <h5>select 的用法</h5>
        <p>select的用法，angular提供了一套比较牛b的实现，而且用法也比较灵活，select是结合ngOptions指令来实现的</p>
        <p>ngOptions指令表达式值有以下几种情况（官方文档）</p>
        <ul>
          <li>for array data sources:
            <ul>
              <li>label <strong>for</strong> value <strong>in</strong> array</li>
              <li>select <strong>as</strong> label <strong>for</strong> value <strong>in</strong> array</li>
              <li>label <strong>group by</strong> group <strong>for</strong> value <strong>in</strong> array</li>
              <li>select <strong>as</strong> label <strong>group by</strong> group <strong>for</strong> value <strong>in</strong> array <strong>track by</strong> trackexpr</li>
            </ul>
          </li>
          <li>for object data sources:
            <ul>
              <li>label <strong>for (</strong>key <strong>,</strong> value<strong>) in</strong> object</li>
              <li>select <strong>as</strong> label <strong>for (</strong>key <strong>,</strong> value<strong>) in</strong> object</li>
              <li>label <strong>group by</strong> group <strong>for (</strong>key<strong>,</strong> value<strong>) in</strong> object</li>
              <li>select <strong>as</strong> label <strong>group by</strong> group <strong>for (</strong>key<strong>,</strong> value<strong>) in</strong> object</li>
            </ul>
          </li>
        </ul>
        <p>Where:</p>
        <ul>
          <li>array / object: an expression which evaluates to an array / object to iterate over.</li>
          <li>value: local variable which will refer to each item in the array or each property value   of object during iteration.</li>
          <li>key: local variable which will refer to a property name in object during iteration.</li>
          <li>label: The result of this expression will be the label for &lt;option&gt; element. The  expression will most likely refer to the value variable (e.g. value.propertyName).</li>
          <li>select: The result of this expression will be bound to the model of the parent &lt;select&gt;   element. If not specified, select expression will default to value.</li>
          <li>group: The result of this expression will be used to group options using the &lt;optgroup&gt;   DOM element.</li>
          <li>trackexpr: Used when working with an array of objects. The result of this expression will be   used to identify the objects in the array. The trackexpr will most likely refer to the  value variable (e.g. value.propertyName).</li>
        </ul>

        <p>下面针对各用法给出详细解释</p>

        <p>注意：<span class="h-web-font-red">用ng-options指令迭代option，如果select对应的ng-model没有初始值，会产生一个空的option，解决的方法可以为ng-model赋初始值，也可以默认设置一个空的option，还可以利用track by trackexpr来设置默认值。
            如果不想要空值，并且也不知道ng-model初始值，我们只能用ng-repeat来循环option了。</span></p>
        <pre>
          <div ng-init="colors = [
                    {name: 'black', shade: 'dark', code: '1'},
                    {name: 'white', shade: 'light', code: '2'},
                    {name: 'red', shade: 'dark', code: '3'},
                    {name: 'blue', shade: 'dark', code: '4'},
                    {name: 'yellow', shade: 'light', code: '5'}
            ];"></div>
          1.产生一个value和text都为空的option
          <select ng-model="color1" ng-options="c.name for c in colors"></select>

          2.默认设置一个value为空字符的option
          <select ng-model="color2"  ng-options="c.name for c in colors">
            <option value="">-- chose color --</option>
          </select>

          3.为ng-model赋一个初始值，当然这个值是ng-options中存在的值
          <span ng-init="color3 = colors[2];"></span>
          <select ng-model="color3"  ng-options="c.name for c in colors">
          </select>

          4.用ng-repeat循环显示option
          <span ng-init="color4 = '3';"></span>
          <select ng-model="color4">
            <option ng-repeat="c in colors" value="{{c.code}}" ng-selected="c.code == color4">{{ c.name}}</option>
          </select>

          5.用track by trackexpr 设置默认值
          在第3种情况中我们给ng-model赋了一个初始值，这个初始值是取ng-options中的某个值，如果我们这样设置，是不起作用的
          <span ng-init="color5 = {name: 'red', shade: 'dark', code: '3'};"></span>
          <select ng-model="color5"  ng-options="c.name for c in colors">
          </select>

          这时我们就可以用track by trackexpr来处理了，trackexpr表达式(e.g. value.propertyName)可以是数组中对象的任意属性
          <span ng-init="color5 = {name: 'red', shade: 'dark', code: '3'};"></span>
          <select ng-model="color5"  ng-options="c.name for c in colors track by c.code">
          </select>
        </pre>
        <p>track by trackexpr的用法，官方提供了一个<a href="http://jsfiddle.net/yTpcu/">例子</a></p>

        <p>我们看一下ng-options 中arrays 和 objects的详细用法，首先看 arrays 的几种情况</p>
        <pre>
           <div ng-init="colors = [
                    {name: 'black', shade: 'dark', code: '1'},
                    {name: 'white', shade: 'light', code: '2'},
                    {name: 'red', shade: 'dark', code: '3'},
                    {name: 'blue', shade: 'dark', code: '4'},
                    {name: 'yellow', shade: 'light', code: '5'}
             ];"></div>
           1.label for value in array
          <span ng-init="color_label = colors[1];"></span>
          <select ng-model="color_lab el"  ng-options="c.name for c in colors">
          </select>
          {{color_label}}

          2.select as label for value in array
          <span ng-init="color_select = '1';"></span>
          <select ng-model="color_sel ect"  ng-options="c.code as c.name for c in colors">
          </select>
          {{color_select}}

          3.label group by group for value in array
          <span ng-init="color_label_group = colors[1];"></span>
          <select ng-model="color_lab el_group"  ng-options="c.name group by c.shade for c in colors">
          </select>
          {{color_label_group}}

          4.select as label group by group for value in array track by trackexpr
          <span ng-init="color_label_group2 = {name: 'white', shade: 'light', code: '2'};"></span>
          <select ng-model="color_lab el_group2"  ng-options="c as c.name group by c.shade for c in colors track by c.name">
          </select>
          {{color_label_group2}}
        </pre>

        <p>以上是arrays的例子，下面看一下objects的几种情况</p>
        <pre>
          <div ng-init="$scope.colors2 = {
                    black: {name: 'black', shade: 'dark', code: '1'},
                    white: {name: 'white', shade: 'light', code: '2'},
                    red: {name: 'red', shade: 'dark', code: '3'},
                    blue: {name: 'blue', shade: 'dark', code: '4'},
                    yellow: {name: 'yellow', shade: 'light', code: '5'}
            };"></div>
          1.label for (key , value) in object
          <span ng-init="color2_label = colors2['black'];"></span>
          <select ng-model="color2_la bel"  ng-options="value.name | uppercase for (key , value) in colors2">
          </select>
          {{color2_label}}

          2.select as label for (key , value) in object
          <span ng-init="color2_select = '3';"></span>
          <select ng-model="color2_se lect"  ng-options="value.code as value.name for (key , value) in colors2">
          </select>
          {{color2_select}}

          3.label group by group for (key, value) in object
          <span ng-init="color2_group = colors2['black'];"></span>
          <select ng-model="color2_gr oup"  ng-options="value.name group by value.shade for (key , value) in colors2">
          </select>
          {{color2_group}}

          4.select as label group by group for (key, value) in object
          <span ng-init="color2_group2 = '4';"></span>
          <select ng-model="color2_gr oup2"  ng-options="value.code as value.name group by value.shade for (key , value) in colors2">
          </select>
          {{color2_group2}}
        </pre>

        <p>关于object的用法可以查看官方<a href="http://jsfiddle.net/salcman/jUP6K/">例子</a></p>

        <p><a href="./angular/examples/myExamples/select-demo.html">点击这里</a>查看完整的例子</p>

        <h4>A 标签和 script 标签</h4>
        <h5>A 标签</h5>
        <p>这里需要注意的是，A tag中当href为空时，angular修改了其默认行为（阻止了其默认行为的发生），即href为空时，点击a标签不会刷新页面</p>
        <p>我们可以这样使用</p>
        <pre>
     <a href="" ng-click="list.addItem()">Add Item</a>
        </pre>

        <h5>script标签</h5>
        <p>secript tag在 angular中主要用于处理模板，我们只要设置 type 属性为 text/ng-template即可。 
          template can be used by ngInclude, ngView or directive templates.</p>
        <p>例子</p>
        <pre>
&lt;!doctype html&gt;
&lt;html ng-app="ngtemplatetest"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;script demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type="text/ng-template" id="/tpl.html"&gt;
      &lt;div&gt;
      &lt;!-- note, templates must have exactly one root element --&gt;
      &lt;h1&gt;{{title}}&lt;/h1&gt;
      &lt;div class="content" ng-transclude&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/script&gt;

  &lt;thing title="title of the template"&gt;
    &lt;p&gt;Some transcluded content&lt;/p&gt;
  &lt;/thing&gt;
  &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;

  &lt;script type="text/javascript"&gt;
    angular.module('ngtemplatetest', [])
        .directive(
                'thing', function() {
                  return {
                    restrict: 'E'
                    , templateUrl: '/tpl.html'
                    , replace: true
                    , transclude: true
                    , scope: {'title': '@'}
                  }
                })
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/script-demo.html">运行效果</a></p>

        <h4>$animate ngAnimate 动画</h4>
        <p>$animate是作为一个service来实现的，动画实现过程主要是通过调用以下几个方法来实现的  </p>
        <ol>
          <li>addClass(element, className, doneCallback)</li>
          <li>enabled(value)</li>
          <li>enter(element, parentElement, afterElement, doneCallback)</li>
          <li>leave(element, doneCallback)</li>
          <li>move(element, parentElement, afterElement, doneCallback)</li>
          <li>removeClass(element, className, doneCallback)</li>
        </ol>
        <p>这几个方法的调用过程详见官网api <a href="http://docs.angularjs.org/api/ngAnimate.$animate">$animate</a></p>
        <p>为了实现动画效果，我们需要引入angular-animate.js，并且在app中依赖该module</p>
        <pre>
    angular.module('app', ['ngAnimate']);
        </pre>
        <p>同时还需要为动画效果定制css</p>
        <p>ngAnimate动画支持的指令有：ngRepeat, ngInclude, ngIf, ngSwitch, ngShow, ngHide, ngView and ngClass.当然我们可以自定义指令通过调用$animate service实现更高级的动画效果。</p>
        <p>Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:</p>
        <table>
          <thead>
            <tr>
              <th>Directive</th>
              <th>Supported Animations</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngRepeat#usage_animations">ngRepeat</a></td>
              <td>enter, leave and move</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ngRoute.directive:ngView#usage_animations">ngView</a></td>
              <td>enter and leave</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngInclude#usage_animations">ngInclude</a></td>
              <td>enter and leave</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngSwitch#usage_animations">ngSwitch</a></td>
              <td>enter and leave</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngIf#usage_animations">ngIf</a></td>
              <td>enter and leave</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngClass#usage_animations">ngClass</a></td>
              <td>add and remove</td>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ng.directive:ngShow#usage_animations">ngShow &amp; ngHide</a></td>
              <td>add and remove (the ng-hide class value)</td>
            </tr>
          </tbody>
        </table>

        <p>Below is an example of how to apply animations to a directive that supports animation hooks。我们可以根据需要来定义这样css样式</p>
        <pre>
    &lt;style type="text/css"&gt;
    .slide.ng-enter, .slide.ng-leave {
    -webkit-transition:0.5s linear all;
    transition:0.5s linear all;
    }
     
    .slide.ng-enter { } /* starting animations for enter */
    .slide.ng-enter-active { } /* terminal animations for enter */
    .slide.ng-leave { } /* starting animations for leave */
    .slide.ng-leave-active { } /* terminal animations for leave */
    &lt;/style&gt;
     
    &lt;!--
    the animate service will automatically add .ng-enter and .ng-leave to the element
    to trigger the CSS transition/animations
    --&gt;
    &lt;ANY class="slide" ng-include="..."&gt;&lt;/ANY>
        </pre>

        <p>angular animate是基于css3（CSS Transitions /CSS Keyframe Animations）实现动画的，如果想让不支持css3的浏览器实现动画效果，我们需要自己重写js代码，如下：</p>
        <pre>
    var ngModule = angular.module('YourApp', []);
    ngModule.animation('.my-crazy-animation', function() {
      return {
        enter: function(element, done) {
          //run the animation here and call done when the animation is complete
          return function(cancelled) {
            //this (optional) function will be called when the animation
            //completes or when the animation is cancelled (the cancelled
            //flag will be set to true if cancelled).
          }
        }
        leave: function(element, done) { },
        move: function(element, done) { },

        //animation that can be triggered before the class is added
        beforeAddClass: function(element, className, done) { },

        //animation that can be triggered after the class is added
        addClass: function(element, className, done) { },

        //animation that can be triggered before the class is removed
        beforeRemoveClass: function(element, className, done) { },

        //animation that can be triggered after the class is removed
        removeClass: function(element, className, done) { }
      };
    });
        </pre>
        <p class="h-web-font-red">所以说，angular animate提供了三种实现方式：CSS Transitions Animations ，CSS Keyframe Animations 和 javascript Animations</p>
        <p>我们可以参考这里学习<a href="http://www.yearofmoo.com/2013/08/remastered-animation-in-angularjs-1-2.html">angular animate</a>，该站点提供了几个实用的例子，<span class="h-web-font-red">非常棒</span>。 </p>
        <p class="h-web-font-red">注意：ng-animate指令在最新版本中不赞成使用，而相应的用css来设置</p>
        <p>关于animate详细的应用，我们可以参考<a href="./angular/examples/myExamples/ng-animate-demo.html">例子</a>，
          因为例子是最好的教程。这些例子摘自上面的<a href="http://www.yearofmoo.com/2013/08/remastered-animation-in-angularjs-1-2.html">链接</a></p>

        <h4>module 和 ngApp 指令</h4>
        <p>
          创建app： angular.module('shoppingCartApp',[]);
        </p>
        <p>创建实例的module提供了以下几个方法</p>
        <ol>
          <li>
            animation(name, animationFactory)
            <p>使用该方法时，必须引入ngAnimate。
              &lt;script src="angular-animate.js"&gt;
              该方法实现的功能是用js自定义动画，参见<a href="http://docs.angularjs.org/api/ngAnimate">ngAnimate</a> 
            </p>
          </li>
          <li>
            config(configFn)
            <p>为module配置相关服务信息，例如配置
              $routeProvider
              $sceProvider.enabled(false);
              $interpolateProvider.startSymbol('[[');
              注册过滤器等等。 <br />
              所有需要配置的信息都可以放到该方法中处理，需要注入依赖的service。
            </p>
          </li>
          <li>
            constant(name, object)
            <p>声明常量，应该放在其他方法（如：config等）之前处理，内部是通过$provide.constant()来实现的</p>
            <pre>
    $provide.constant('SHARD_HEIGHT', 306);
     
    $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);
     
    $provide.constant('double', function(value) {
    return value * 2;
    });
            </pre>
          </li>
          <li>
            controller(name, constructor)
            <p>
              创建controller，是通过$controllerProvider.register()来实现的，创建的controller可以作为指令 ng-controller来使用，也可用在其他指令中。
            </p>
          </li>
          <li>
            directive(name, directiveFactory)
            <p>创建指令，是通过 $compileProvider.directive()来实现的</p>
          </li>
          <li>
            factory(name, providerFunction)
            <p>用来注册一个service factory ，是通过$provide.factory()来实现的。我们可以在factory中创建一些跟http打交道的服务等。</p>
            <pre>
   $provide.factory('ping', ['$http', function($http) {
      return function ping() {
      return $http.send('/ping');
      };
    }]);
            </pre>
          </li>
          <li>
            filter(name, filterFactory)
            <p>用来自定义过滤器，是通过 $filterProvider.register()来实现的，下面代码简单的创建了一个过滤器，greet</p>
            <pre>
function MyModule($provide, $filterProvider) {
  // create a service to demonstrate injection (not always needed)
  $provide.value('greet', function(name){
    return 'Hello ' + name + '!';
  });
 
  // register a filter factory which uses the
  // greet service to demonstrate DI.
  $filterProvider.register('greet', function(greet){
    // return the filter function which uses the greet service
    // to generate salutation
    return function(text) {
      // filters need to be forgiving so check input validity
      return text && greet(text) || text;
    };
  });
}
            </pre>
          </li>
          <li>
            provider(name, providerType)
            <p>为一个service提供一个代理provider，是通过$provide.provider()实现的。比如：the $log service has a provider called $logProvider.
              用$logProvider来提供一些额外的方法。</p>
          </li>
          <li>
            run(initializationFn)
            <p>当用injector 来加载该module时，调用该方法来实例化</p>
          </li>
          <li>
            service(name, constructor)
            <p>注册一个service constructor，是通过$provide.service()实现的</p>
          </li>
          <li>
            value(name, object)
            <p>注册一个value服务，用value(name, object)来实现的，通俗的讲就是定义一些变量，与 constant services类似</p>
            <pre>
    $provide.value('ADMIN_USER', 'admin');
     
    $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });
     
    $provide.value('halfOf', function(value) {
    return value / 2;
    });
            </pre>
          </li>
        </ol>

        <p>ng-app是不能嵌套的</p>
        <p></p>

        <h4>Controller 和 ngController指令</h4>
        <p>
          controller可以定义为全局的和局部的，controller名字的首字母应该大写。
        </p>
        <pre>
    function GreetingCtrl($scope) {
       $scope.greeting = 'Hola!';
    }

    var myApp = angular.module('myApp',[]);
    myApp.controller('GreetingCtrl', ['$scope', function($scope) {
       $scope.greeting = 'Hola!';
    }]);
        </pre>
        <p>写例子用全局和局部都可以，但做项目或产品还是用局部的，原因就不多说了，你懂得。在controller中我们可以为scope添加方法或变量，跟view来交互。</p>
        <p>controller 在什么情况下使用，怎样才能正确的使用，我们看看官方提供的答案吧。官方中提到了在一个controller中一般不要做得太多，不要把各种逻辑都写在controller中，
          应该仅仅包括一个业务功能模块的逻辑，一些复杂的逻辑可以通过 service依赖注入。controller中不应该包含以下内容：
        </p>
        <ul>
          <li> 对DOM元素的操作：controller中应该仅仅包括业务逻辑的处理，而不要包括对DOM元素的操作（对这些操作应该放到 directive中，比如对dom元素属性的修改，节点的增加等） </li>
          <li>Input formatting — Use <a href="http://docs.angularjs.org/guide/forms">angular form controls</a> instead.</li>
          <li>Output filtering — Use <a href="http://code.angularjs.org/guide/filter">angular filters</a> instead.</li>
          <li>Sharing stateless or stateful code across Controllers — Use <a href="http://code.angularjs.org/guide/dev_guide.services">angular services</a> instead.</li>
          <li>Managing the life-cycle of other components (for example, to create service instances).</li>
        </ul>
        <p>
          Controller 用法：<br />
          1.Controller 可以 通过 ngController directive or $route service 关联 Angular Scope Objects <br />
          2.Controller 中定义的 scope方法可以传递参数，可以是scope中定义的变量，也可以是常量<br />
          3.Controller 可以层级嵌套，scope遵循 A. child scope 继承 parent scope，B. 先从 child scope 中查询变量，找不到再从parent scope中查找，直至rootScope <br />
          <a href="./angular/examples/myExamples/ng-controller-demo.html">点击查看Controller综合实例</a>
        </p>

        <h4>Services</h4>
        <p>在Angular中提供了几个service，比如$http , $location等。在开发中运用是通过factory函数来定义的。定义service的好处是可以把一些公用的code和data封装到service中。
          一个service可以返回一个对象或function，在其他controller, service, filter or directive中依赖注入该service。
        </p>
        <p>Registering Services</p>
        <pre>
    //Using the angular.Module api:
    var myModule = angular.module('myModule', []);
    myModule.factory('serviceId', function() {
        var shinyNewServiceInstance;
        //factory function body that constructs shinyNewServiceInstance
        return shinyNewServiceInstance;
    });

    //Using the $provide service:
    angular.module('myModule', [], function($provide) {
    $provide.factory('serviceId', function() {
      var shinyNewServiceInstance;
      //factory function body that constructs shinyNewServiceInstance
      return shinyNewServiceInstance;
      });
    });
        </pre>
        <p>service也可以依赖其他service 而注入，跟其他注入方式是一样的。另外service是单例的，在每个注射器中只有一个实例。</p>
        <p>下面看一个用service管理data的例子</p>
        <p><a href="./angular/examples/myExamples/ng-service-demo.html"> View independent business logic: Services</a></p>
        <p>下面是一个用 jasmine实现的javascript unit test 例子，有错误，待修改</p>
        <p><a href="./angular/examples/myExamples/testingServices.html"> Testing Angular Services Using Jasmine</a></p>

        <h4>$location service</h4>
        <p>$location是基于window.location来实现的，两者之间是关联的，一方发生改变，另一方也会改变。$location服务可以监听或改变url。
          $location的改变不会引起整个浏览器的刷新，如果想让整个浏览器刷新，可以用$window.location.href.
        </p>
        <p><a href="./angular/examples/myExamples/$location-demo.html">例子</a></p>

        <h4>$sce service</h4>
        <p>$sce (Strict Contextual Escaping)是用来处理html内容的service，主要用来安全的解析innerHTML片段。在1.2.x版本中
          默认 $sce 是激活的，如果我们不想让$sce起作用，我们可以调用以下代码来设置。
        </p>
        <pre>
    angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
        // Completely disable SCE. For demonstration purposes only!
        // Do not use in new projects.
        $sceProvider.enabled(false);
    });
        </pre>
        <p>
          如果把$sce设为disable，那么对于 &lt;div ng-bind-html="userHtml"&gt;中userHtml可以是任意的html代码，包括style但不包括script（会报错）。
        </p>
        <p><a href="./angular/examples/myExamples/$sce-disabled-demo.html">例子</a></p>

        <p>如果$sce设为enabled后，在解析html片段时会忽略部分属性 和 style标签等。但有时又想要完整的解析html时，我们可以调用$sce提供的方法，
          该方法与$sceDelegate提供的方法是通用的，只是简短写法。$sceDelegate提供了getTrusted(type, maybeTrusted)，trustAs(type, value)和valueOf(value)三个方法
          $sce中的方法都是围绕这三个方法实现的变体。
        </p>
        <p>注意：在$sce默认设置下，使用指令ng-bind-html时，如果不调用方法$sce需要引入angular-sanitize.js，并在module中加入依赖 ngSanitize</p>
        <p>$sce 常用的方法有 $sce.trustAsHtml(html)，对应 $sceDelegate.trustAs($sce.HTML, html) </p>

        <p><a href="./angular/examples/myExamples/$sce-demo.html">例子</a></p>

        <h4>编译器(complier)</h4>
        <p>编译器是AngularJS提供的一项服务，它通过遍历DOM来查找和它相关的属性。整个编译的过程分为两个阶段。</p>
        <ul>
          <li>
            <strong>编译</strong>： 遍历DOM并且收集所有的相关指令，生成一个链接函数。
          </li>
          <li>
            <strong>链接</strong>： 给指令绑定一个作用域，生成一个动态的视图。作用域模型的任何改变都会反映到视图上，并且视图上的任何用户操作也都会反映到作用域模型。这使得作用域模型成为你的业务逻辑里唯一要关心的东西。
          </li>
        </ul>
        <p>有一些指令，比如ng-repeat会为数据集合里的每一项DOM元素都克隆一次。将整个编译过程分为<strong>编译</strong>和<strong>链接</strong>两个阶段的作法改善了整体的性能，因为克隆出来的模板总共只需要被编译一次，然后链接到各自的模型实例上就行了。</p>


        <h4>使用过滤器格式化数据</h4>
        <p>
          过滤器允许你在模板中使用插值方式声明如何转换数据并显示给用户。内部代码是通过 $filterProvider service 实现的。 使用过滤器的语法如下:
        </p>
        <pre>
    {{expression| filterName : parameter1 : … parameterN }}
    {{ expression | filter1 | filter2 | ... }}
        </pre>
        <p>其中表达式是任意的Angular表达式, filterName是你想使用的过滤器名称, 过滤器的参数使用冒号分割。 参数自身也可以是任意有效的Angular表达式。
          第二个表达式中表明过滤器的结果可以用到另一个过滤器中</p>
        <p>Angular自带了几个过滤器, 像我们已经看到的currency</p>
        <pre>{{12.9| currency}}  </pre>
        <p>这段代码显示如下:</p>
        <p>$12.9</p>
        <p>我们不仅限于使用绑定的过滤器(Angular内置的), 你可以简单的编写自己的过滤器. 例如, 如果我们想创建一个过滤器来让标题的首字母大写, 我们可以像下面这样做:</p>
        <pre>
    var homeModule = angular.module('HomeModule', []);
    homeModule.filter('titleCase', function(){
        var titleCaseFilter = function(input){
            var words = input.split(' ');
            for(var i = 0; i < words.length; i++){
                words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);
            }

            return words.join(' ');
        };
        return titleCaseFilter;
    });
        </pre>

        <p>titleCase例子:</p>
        <pre>
    &lt;body ng-app="HomeModule" ng-controller="HomeController"&gt;
          &lt;h1&gt;{{pageHeading| titleCase}}&lt;/h1&gt;
    &lt;/body&gt;
        </pre>
        <p>我们也可以调用$provide 和 $filterProvider来注册一个过滤器</p>

        <pre>
    // Filter registration
    function MyModule($provide, $filterProvider) {
        // create a service to demonstrate injection (not always needed)
        $provide.value('greet', function(name){
           return 'Hello ' + name + '!';
        });
     
    // register a filter factory which uses the
    // greet service to demonstrate DI.
    $filterProvider.register('greet', function(greet){
      // return the filter function which uses the greet service
      // to generate salutation
      return function(text) {
        // filters need to be forgiving so check input validity
        return text && greet(text) || text;
        };
      });
    }
        </pre>

        <p><a href="./angular/examples/myExamples/filters-demo.html">点击查看例子</a></p>

        <p>Angular默认提供了以下几个过滤器</p>
        <ul>
          <li>currency</li>
          <li>date</li>
          <li>filter</li>
          <li>json</li>
          <li>limitTo</li>
          <li>lowercase</li>
          <li>number</li>
          <li>orderBy</li>
          <li>uppercase</li>
        </ul>

        <h5>currency</h5>
        <p>用法：</p>
        <p>In HTML Template Binding： {{ currency_expression | currency[:symbol] }}</p>
        <p>In JavaScript： $filter('currency')(amount[, symbol])</p>

        <h5>date</h5>
        <p>用法：</p>
        <p>In HTML Template Binding：
          {{ date_expression | date[:format] }}</p>
        <p>In JavaScript：
          $filter('date')(date[, format]) </p>
        <p>例子</p>
        <pre>
<span ng-non-bindable>{{1288323623006| date:'medium'}}</span>:
{{1288323623006| date:'medium'}}<br>
<span ng-non-bindable>{{1288323623006| date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
{{1288323623006| date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
<span ng-non-bindable>{{1288323623006| date:'MM/dd/yyyy @ h:mma'}}</span>:
{{'1288323623006'| date:'MM/dd/yyyy @ h:mma'}}<br>
        </pre>

        <p>format string can be composed of the following elements:</p>
        <ul>
          <li>'yyyy': 4 digit representation of year (e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010)</li>
          <li>'yy': 2 digit representation of year, padded (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10)</li>
          <li>'y': 1 digit representation of year, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199)</li>
          <li>'MMMM': Month in year (January-December)</li>
          <li>'MMM': Month in year (Jan-Dec)</li>
          <li>'MM': Month in year, padded (01-12)</li>
          <li>'M': Month in year (1-12)</li>
          <li>'dd': Day in month, padded (01-31)</li>
          <li>'d': Day in month (1-31)</li>
          <li>'EEEE': Day in Week,(Sunday-Saturday)</li>
          <li>'EEE': Day in Week, (Sun-Sat)</li>
          <li>'HH': Hour in day, padded (00-23)</li>
          <li>'H': Hour in day (0-23)</li>
          <li>'hh': Hour in am/pm, padded (01-12)</li>
          <li>'h': Hour in am/pm, (1-12)</li>
          <li>'mm': Minute in hour, padded (00-59)</li>
          <li>'m': Minute in hour (0-59)</li>
          <li>'ss': Second in minute, padded (00-59)</li>
          <li>'s': Second in minute (0-59)</li>
          <li>'.sss' or ',sss': Millisecond in second, padded (000-999)</li>
          <li>'a': am/pm marker</li>
          <li>'Z': 4 digit (+sign) representation of the timezone offset (-1200-+1200)</li>
        </ul>
        <p>format string can also be one of the following predefined <a href="http://docs.angularjs.org/guide/i18n">localizable formats</a>:</p>
        <ul>
          <li>'medium': equivalent to 'MMM d, y h:mm:ss a' for en_US locale  (e.g. Sep 3, 2010 12:05:08 pm)</li>
          <li>'short': equivalent to 'M/d/yy h:mm a' for en_US  locale (e.g. 9/3/10 12:05 pm)</li>
          <li>'fullDate': equivalent to 'EEEE, MMMM d,y' for en_US  locale  (e.g. Friday, September 3, 2010)</li>
          <li>'longDate': equivalent to 'MMMM d, y' for en_US  locale (e.g. September 3, 2010)</li>
          <li>'mediumDate': equivalent to 'MMM d, y' for en_US  locale (e.g. Sep 3, 2010)</li>
          <li>'shortDate': equivalent to 'M/d/yy' for en_US locale (e.g. 9/3/10)</li>
          <li>'mediumTime': equivalent to 'h:mm:ss a' for en_US locale (e.g. 12:05:08 pm)</li>
          <li>'shortTime': equivalent to 'h:mm a' for en_US locale (e.g. 12:05 pm)</li>
        </ul>
        <p>format string can contain literal values. These need to be quoted with single quotes (e.g.  "h 'in the morning'"). In order to output single quote, use two single quotes in a sequence  (e.g. "h 'o''clock'").</p>

        <h5>filter 过滤数组列表</h5>
        <p>用法：</p>
        <p>In HTML Template Binding：
          {{ filter_expression | filter:expression:comparator }} </p>
        <p>In JavaScript：
          $filter('filter')(array, expression, comparator) </p>
        <p>expression 可以是string，object或function；comparator为function，true或false(undefined)</p>
        <p>注意当expression 是对象时，如果设置了对象的属性为 $ 表示全属性匹配</p>
        <pre>
  {{ data | filter: {name: 'A'} }}
  {{ data | filter: {$: '3'} }}
  {{ data | filter: {$: '!3'} }}
        </pre>
        <p>expression 是 function时</p>

        <pre>
&lt;div ng-controller="TestCtrl"&gt;
    {{ data | filter: f }}
&lt;/div&gt;
 &lt;script type="text/javascript"&gt;
  var TestCtrl = function($scope){
    $scope.data = [
      {name: 'B', age: 4},  
      {name: 'A', age: 1},  
      {name: 'D', age: 3},  
      {name: 'C', age: 3},  
    ];
  
    $scope.f = function(e){
      return e.age &gt; 2;
    }
  }
  angular.bootstrap(document.documentElement);
  &lt;/script&gt;
        </pre>
        <p><a href="./angular/examples/myExamples/filter-demo.html">点击查看例子</a></p>

        <h5>json 过滤器</h5>
        <p>convert a JavaScript object into JSON string</p>
        <p>用法：</p>
        <p>In HTML Template Binding：
          {{ json_expression | json }} </p>
        <p>In JavaScript：
          $filter('json')(object)  </p>
        <p>例子：{{ {'name':'value'} | json }} 输出结果为 {"name": "value"}</p>

        <h5>limitTo 过滤器</h5>
        <p>处理字符串或数组，截取前（或后）几个数据，当值为负数时，指从后往前截取到limitTo，注意：<span class="h-web-font-red">是从0开始，截取到limitTo</span></p>
        <p><a href="./angular/examples/myExamples/limitTo-demo.html">点击查看例子</a></p>

        <h5>lowercase uppercase 过滤器</h5>
        <p>大小写转换</p>

        <p>用法：</p>
        <p>In HTML Template Binding：
          {{ uppercase_expression | uppercase }}  </p>
        <p>In JavaScript：
          $filter('uppercase')()  </p>

        <h5>number 过滤器</h5>
        <p>格式化数字，用千分位处理，默认保留三位小数。如果是非数字则返回空</p>

        <p>用法：</p>
        <p>In HTML Template Binding：
          {{ number_expression | number[:fractionSize] }}   </p>
        <p>In JavaScript：
          $filter('number')(number[, fractionSize])  </p>
        <p>对于字符串转换成数字，不是简单的调用parseFloat方法，内容做了处理，待研究</p>
        <p><a href="./angular/examples/myExamples/number-demo.html">点击查看例子</a></p>

        <h5>orderBy 排序过滤器</h5>
        <p>排序过滤器：    filter:orderBy(array, expression[, reverse]);</p>
        <p>必须是对数组进行排序，reverse设为true为倒序，不设置或设为false为正序。expression可以是字符串，表示object的属性，也可以是function，一个比较器，还可以是array，一个function或string组成的array，
          首先按第一个比较器比较，当相等时再按第二个比较器，以此类推。
        </p>
        <p><a href="./angular/examples/myExamples/orderBy-demo.html">点击查看例子</a></p>

        <h4>Angular global API</h4>
        <p>基于1.2.x版本，Angular共提供了以下属性和方法</p>
        <ul>
          <li> <a href="http://docs.angularjs.org/api/angular.bind">angular.bind</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.bootstrap">angular.bootstrap</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.copy">angular.copy</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.element">angular.element</a></li>
          <li> 
            <a href="http://docs.angularjs.org/api/angular.equals">angular.equals</a>
            <p>不同于javascript中原生的 ===，官方的描述</p>
            <p>Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and objects.
              Two objects or values are considered equivalent if at least one of the following is true:
              Both objects or values pass === comparison.
              Both objects or values are of the same type and all of their properties are equal by comparing them with angular.equals.
              Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
              Both values represent the same regular expression (In JavasScript, /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual representation matches).
              During a property comparison, properties of function type and properties with names that begin with $ are ignored.
              Scope and DOMWindow objects are being compared only by identify (===).
            </p>
          </li>
          <li> <a href="http://docs.angularjs.org/api/angular.extend">angular.extend</a>
            <p> angular.extend(dst, src);dst和src都是json格式的数据，不同于jQuery中的extend，可以多个参数使用</p></li>
          <li> <a href="http://docs.angularjs.org/api/angular.forEach">angular.forEach</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.fromJson">angular.fromJson</a>
            <p>    angular.fromJson(json);字符串转换为json数据，如果非字符串则返回json</p>
          </li>
          <li> <a href="http://docs.angularjs.org/api/angular.identity">angular.identity</a>
            <p>该方法是返回函数第一个参数值，比如</p>
            <p>
              function transformer(transformationFn, value) { <br />
              return (transformationFn || angular.identity)(value);<br />
              };<br />
              如果transformationFn没有定义，则返回value
            </p>
          </li>
          <li> <a href="http://docs.angularjs.org/api/angular.injector">angular.injector</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isArray">angular.isArray</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isDate">angular.isDate</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isDefined">angular.isDefined</a>
            <p>判断是否被定义了，即不等于undefined</p>
          </li>
          <li> <a href="http://docs.angularjs.org/api/angular.isElement">angular.isElement</a>
            <p>判断是否是一个DOM element或者被jQuery包裹的一个DOM element元素</p></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isFunction">angular.isFunction</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isNumber">angular.isNumber</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isObject">angular.isObject</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isString">angular.isString</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.isUndefined">angular.isUndefined</a>
            <p>判断是否是一个未定义的变量，与angular.isDefined相反</p></li>
          <li> <a href="http://docs.angularjs.org/api/angular.lowercase">angular.lowercase</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.mock">angular.mock</a>
            <p>在文件angular-mocks.js中定义，主要是增强一些javascript原生提供的功能，比如$log，date,$timeout等</p></li>
          <li> <a href="http://docs.angularjs.org/api/angular.module">angular.module</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.noop">angular.noop</a>
            <p>空函数</p></li>
          <li> <a href="http://docs.angularjs.org/api/angular.toJson">angular.toJson</a>
            <p>与angular.fromJson相反，把一个json格式的数据转换为字符串，但内部做了处理，比如以$开头将或略等。</p>
          </li>
          <li> <a href="http://docs.angularjs.org/api/angular.uppercase">angular.uppercase</a></li>
          <li> <a href="http://docs.angularjs.org/api/angular.version">angular.version</a>
            <p>是一个属性，显示版本信息</p>
          </li>
        </ul>
        <p>这里重点介绍其中一部分</p>

        <h5>angular.bind</h5>
        <p>绑定上下文函数，与 ES5 提供的bind函数不一样，待研究</p>
        <p>例子</p>
        <pre>
  var f = angular.bind({a: 'xx'},
    function(){
      console.log(this.a);
    }
  );
  f();
        </pre>
        <h5>angular.bootstrap</h5>
        <p>    angular.bootstrap(element[, modules]); 用angular解析代码</p>

        <h5>angular.copy</h5>
        <p>深度copy，angular.copy(source[, destination]); 数据应该是json格式的数据，是把source copy到 destination中</p>
        <p><a href="./angular/examples/myExamples/copy-demo.html">点击查看例子</a></p>

        <h5>angular.element</h5>
        <p>源码中是这样处理的</p>
        <pre>
  function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    // Method signature:
    //     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)
    jqLitePatchJQueryRemove('remove', true, true, false);
    jqLitePatchJQueryRemove('empty', false, false, false);
    jqLitePatchJQueryRemove('html', false, false, true);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}
        </pre>
        <p>从源码中可以看出，通过调用bindJQuery，把jqLite赋值给angular.element。
          对于jqLite，如果引入了jQuery，则使用jQuery提供的方法，并扩展了jQuery几个属性和方法，同时对remove、empty和html进行了重写，
          否则使用angular提供的jqLite。因此书写jQuery的方法就可以直接用angular.element来替代。</p>
        <p>angular jqLite provides only the following jQuery methods（部分方法跟jQuery中有差别）</p>
        <ol>
          <li><a href="http://api.jquery.com/addClass/">addClass()</a></li>
          <li><a href="http://api.jquery.com/after/">after()</a></li>
          <li><a href="http://api.jquery.com/append/">append()</a></li>
          <li><a href="http://api.jquery.com/attr/">attr()</a></li>
          <li><a href="http://api.jquery.com/on/">bind()</a> - Does not support namespaces, selectors or eventData</li>
          <li><a href="http://api.jquery.com/children/">children()</a> - Does not support selectors</li>
          <li><a href="http://api.jquery.com/clone/">clone()</a></li>
          <li><a href="http://api.jquery.com/contents/">contents()</a></li>
          <li><a href="http://api.jquery.com/css/">css()</a></li>
          <li><a href="http://api.jquery.com/data/">data()</a></li>
          <li><a href="http://api.jquery.com/eq/">eq()</a></li>
          <li><a href="http://api.jquery.com/find/">find()</a> - Limited to lookups by tag name</li>
          <li><a href="http://api.jquery.com/hasClass/">hasClass()</a></li>
          <li><a href="http://api.jquery.com/html/">html()</a></li>
          <li><a href="http://api.jquery.com/next/">next()</a> - Does not support selectors</li>
          <li><a href="http://api.jquery.com/on/">on()</a> - Does not support namespaces, selectors or eventData</li>
          <li><a href="http://api.jquery.com/off/">off()</a> - Does not support namespaces or selectors</li>
          <li><a href="http://api.jquery.com/parent/">parent()</a> - Does not support selectors</li>
          <li><a href="http://api.jquery.com/prepend/">prepend()</a></li>
          <li><a href="http://api.jquery.com/prop/">prop()</a></li>
          <li><a href="http://api.jquery.com/ready/">ready()</a></li>
          <li><a href="http://api.jquery.com/remove/">remove()</a></li>
          <li><a href="http://api.jquery.com/removeAttr/">removeAttr()</a></li>
          <li><a href="http://api.jquery.com/removeClass/">removeClass()</a></li>
          <li><a href="http://api.jquery.com/removeData/">removeData()</a></li>
          <li><a href="http://api.jquery.com/replaceWith/">replaceWith()</a></li>
          <li><a href="http://api.jquery.com/text/">text()</a></li>
          <li><a href="http://api.jquery.com/toggleClass/">toggleClass()</a></li>
          <li><a href="http://api.jquery.com/triggerHandler/">triggerHandler()</a> - Passes a dummy event object to handlers.</li>
          <li><a href="http://api.jquery.com/off/">unbind()</a> - Does not support namespaces</li>
          <li><a href="http://api.jquery.com/val/">val()</a></li>
          <li><a href="http://api.jquery.com/wrap/">wrap()</a></li>
        </ol>

        <h5>angular.forEach</h5>
        <p>该方法迭代处理object或array，用法如下：</p>
        <p>
          object : <br />
          angular.forEach(obj, function(value, key){}[, context]); <br />
          array : <br />
          angular.forEach(array, function(item, index){}[, context]); <br />
        </p>
        <p>这里需要注意的是该方法中提供了context，如果不设置，默认为iterator函数中的第一个参数（value或item）。
          还需注意的是value或item是一个引用，如果改变这些值的话会改变object或array的值，这与jQuery提供的each不一样，jQuery不会改变。</p>
        <pre>
var values = {name: 'misko', gender: 'male'};
var log = [];
angular.forEach(values, function(value, key){
  //这里的this是指log
  this.push(key + ': ' + value);
}, log);
console.info(log);//["name: misko", "gender: male"]

//与jQuery中each方法对比
var students = [{name: 'misko', gender: 'male'},{name: 'misko2', gender: 'female'}];
angular.forEach(students, function(item,index){
   item['index'] = index;
});
console.info(students);//[Object { name="misko", gender="male", index=0}, Object { name="misko2", gender="female", index=1}]
students = [{name: 'misko', gender: 'male'},{name: 'misko2', gender: 'female'}];
$(values).each(function(item,index){
   item['index'] = index;
});
console.info(students);//[Object { name="misko", gender="male"}, Object { name="misko2", gender="female"}]
        </pre>

        <h5>angular.injector</h5>
        <p>这是一个比较重要的函数，是用来创建一个注射器的，可以实现依赖注入。该方法创建了一个service，该方法比较复杂，待研究。</p>

        <h5>angular.module</h5>
        <p>用来创建或返回一个Angular modules，参数是两个或两个以上表示创建，参数是一个表示返回。
          A module is a collection of services, directives, filters, and configuration information. angular.</p>
        <pre>
    // Create a new module
    var myModule = angular.module('myModule', []);
     
    // register a new service
    myModule.value('appName', 'MyCoolApp');
     
    // configure existing services inside initialization blocks.
    myModule.config(function($locationProvider) {
    // Configure existing providers
    $locationProvider.hashPrefix('!');
    });</pre>

        <h4>路由 ngRoute</h4>
        <p>ngRoute 是属于一个module，在最新的1.2.x版本中，如果想要使用路由功能，需要单独引入angular-route.js文件，
          并需要加入依赖的module，angular.module('app', ['ngRoute']);</p>
        <pre>
    &lt;script src="angular-route.js"&gt;
    angular.module('app', ['ngRoute']);  </pre>
        <p>与ngRoute结合使用的service和directive有：</p>
        <table>
          <caption>directive</caption>
          <tbody>
            <tr>
              <th>Name</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><a href="http://docs.angularjs.org/api/ngRoute.directive:ngView">ngView</a></td>
              <td>Overview</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>service</caption>
          <tbody>
            <tr>
              <th>Name</th>
              <th>Description</th>
            </tr>
            <tr ng-repeat="component in section.components">
              <td><a href="http://docs.angularjs.org/api/ngRoute.$route">ngRoute.$route</a></td>
              <td>$route is used for deep-linking URLs to controllers and views (HTML partials).</td>
            </tr>
            <tr ng-repeat="component in section.components">
              <td><a href="http://docs.angularjs.org/api/ngRoute.$routeParams">ngRoute.$routeParams</a></td>
              <td>The $routeParams service allows you to retrieve the current set of route parameters.</td>
            </tr>
            <tr ng-repeat="component in section.components">
              <td><a href="http://docs.angularjs.org/api/ngRoute.$routeProvider">ngRoute.$routeProvider</a></td>
              <td>Used for configuring routes. See $route for an example.</td>
            </tr>
          </tbody>
        </table>

        <h5>ngView指令</h5>
        <p>路由中用到的指令ngView由ngRoute来控制，该指令包含了可渲染的模板内容，当路由改变时，根据不同的路由加载不同的模板，编译后渲染到ngView中，该指令支持以下animate</p>
        <ul>
          <li>enter - animation is used to bring new content into the browser.</li>
          <li>leave - animation is used to animate existing content away.</li>
          <li>The enter and leave animation occur concurrently.</li>
        </ul>
        <p><a href="./angular/examples/myExamples/ng-view-demo.html">点击查看例子</a></p>

        <h5>$route service</h5>
        <p>The $route service is typically used in conjunction with the ngView directive and the $routeParams service.</p>
        <p>该service依赖$location和$routeParams，他会监视$location.url()并根据不同的路由改变其内容。</p>
        <p>$route提供的 <br />
          方法有reload()：重新加载路由 <br />
          属性有： <br />
          current 定义当前路由信息，该属性包含：controller、templateUrl、params和locals（该属性又包含$template和$scope） <br />
          routes，包含所有路由 <br />
          事件有： <br />
          $routeChangeError、$routeChangeStart、$routeChangeSuccess和$routeUpdate
        </p>

        <h5>$routeParams service</h5>
        <p>把路由中各参数返回（map形式），参数的定义格式是用:开头，例如:</p>

        <pre>
    $routeProvider.when('/Chapter/:chapterId/Section/:sectionId', {...})

    // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
    // Route: /Chapter/:chapterId/Section/:sectionId
    //
    // Then
    $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}
        </pre>

        <h5>$routeProvider</h5>
        <p>$routeProvider是用来关联模板和路由以及controller的，该service提供了两个方法</p>
        <ol>
          <li>when(path, route)
            <p>设置路由，path是一个字符串，会匹配$location.path，定义格式可以是(:name)或(:name*)。例如：/color/:color/largecode/:largecode*\/edit 会匹配 /color/brown/largecode/code/with/slashs/edit，
              匹配的值为 <br />
              color: brown<br />
              largecode: code/with/slashs
            </p>
            <p>参数 route是一个json对象，对象中可以设置以下属性</p>
            <ul>
              <li>controller 一个controller，字符串或函数</li>
              <li>controllerAs controller的别名（当前上下文）</li>
              <li>template html模板，他优先templateUrl，template也可以是一个function，用来返回html模板数据</li>
              <li>templateUrl 字符串或函数，用来指明外部html模板</li>
              <li>resolve  {Object.<string, function>=} 可选的</li>
                <li>redirectTo  {(string|function())=} </li>
                <li>[reloadOnSearch=true] - {boolean=} - reload route when only $location.search() or $location.hash() changes.
                  If the option is set to false and url in the browser changes, then $routeUpdate event is broadcasted on the root scope.
                </li>
                <li>[caseInsensitiveMatch=false] - {boolean=} - match routes without being case sensitive
                  If the option is set to true, then the particular route can be matched without being case sensitive
                </li>
            </ul>
          </li>
          <li>otherwise(params)
            <p>设置when中定义的默认路由，例如： $routeProvider.otherwise({redirectTo: '/Book/Moby'});</p>
          </li>
        </ol>
        <p>详细说明，官方没有提供更多的例子</p>

        <p>对于路由的操作，ui-router提供了更好的操作，详见 <a href="https://github.com/angular-ui/ui-router">ui-router</a></p>

        <h4>指令(Directives)</h4>
        <p>官方关于指令的详解为：<a href="http://docs.angularjs.org/api/ng.$compile">$compile</a></p>
        <h5>指令的使用</h5>
        <p>指令指示的是“当关联的HTML结构进入编译阶段时应该执行的操作”。指令可以写在元素的名称里，属性里，css类名里，注释里。下面有几个功能相同的使用ng-bind指令的例子。</p>
        <pre>
<span ng-bind="exp"></span>
<span class="ng-bind: exp;"></span>
<ng-bind></ng-bind>
<!-- directive: ng-bind exp -->
        </pre>
        <p>
          指令本质上只是一个当编译器编译到相关DOM时需要执行的函数。Angular指令的定义不仅仅包含字符串模板绑定，而且还有行为结构体的定义。
          下面是一条能让元素变得可拖拽的指令。
        </p>
        <pre>
    <span draggable>Drag ME</span>
    angular.module('directiveExample', []).
        directive('draggable', function($document) {
          var startX = 0, startY = 0, x = 0, y = 0;
          return function(scope, element, attr) {
            element.css({
              position: 'relative',
              border: '1px solid red',
              backgroundColor: 'lightgrey',
              cursor: 'pointer'
            });
            element.bind('mousedown', function(event) {
              $document.unbind('mousemove', mousemove);
              $document.unbind('mouseup', mouseup);
              startX = event.screenX - x;
              startY = event.screenY - y;
              $document.bind('mousemove', mousemove);
              $document.bind('mouseup', mouseup);
            });

            function mousemove(event) {
              y = event.screenY - startY;
              x = event.screenX - startX;
              element.css({
                top: y + 'px',
                left: x + 'px'
              });
            }

            function mouseup() {
              $document.unbind('mousemove', mousemove);
              $document.unbind('mouseup', mouseup);
            }
          };
        });
        </pre>
        <p><a href="./angular/examples/myExamples/directive-demo.html">运行效果</a></p>

        <h5>指令的执行过程</h5>
        <p>先看一下代码是怎么实现的，首先调用$CompileProvider中的方法directive来注册指令，然后调用collectDirectives查找指令，查找指令过程中可能会调用addDirective来绑定指令，该方法也在$CompileProvider中定义。
          找到后会返回到compileNodes方法中，获取 nodeLinkFn 和childLinkFn函数，如果linkFnFound为true，然后返回compositeLinkFn。compileNodes方法中会递归处理孩子节点的相关指令。最后回到compile函数中编译指令内容。
          编译过程中内部会调用指令定义的函数。
        </p>
        <p>具体执行过程为：</p>
        <ul>
          <li>找到ng-app入口，把 DOM 结构扔给 $compile（$CompileProvider） 函数处理 </li>
          <ul>
            <li>匹配找出 DOM 中包含的所有指令引用</li>
            <li>把指令关联到 DOM</li>
            <li>关联到 DOM 的多个指令按权重排列</li>
            <li>执行指令中的 compile 函数（改变 DOM 结构，返回 link 函数）</li>
            <li>得到的所有 link 函数组成一个列表作为 $compile 函数的返回</li>
          </ul>
          </li>
          <li>执行 link 函数（连接模板的 scope）。</li>
        </ul>
        <h5>定义指令相关属性</h5>
        <p>一个最简单的定义就是直接返回函数，这个函数会作为directive的link属性（即代码中的nodeLinkFn，这个会在compile中会被调用）</p>
        <pre>
    angular.module('directiveExample', []).
        directive('draggable', function($document) {
          return function(scope, element, attr) {
            //...
          };
        });
        </pre>
        <p>题外话，上例中的$document是一个依赖注入，标准写法为：['$document',function($document){}]。在angular中提供的方法中都可以依赖注入</p>
        <p>下面看一下一个完整的directive定义相关属性</p>
        <ul>
          <li>name: 指令 controller 的名字，方便其它指令引用，用require引入。</li>
          <li>priority：指令执行优先级，默认为0</li>
          <li>terminal：是否以当前指令的权重为结束界限。如果这值设置为 true ，则节点中权重小于当前指令的其它指令不会被执行。相同权重的会执行。</li>
          <li>scope： 如果为true，则会创建新的scope，如果scope是一个object{}时，他会创建一个隔离的scope，对象中的属性是父scope中的一个别名，即该属性可以指定父scope中定义的变量，
            变量值在内部代码中会传递给该别名。该别名类型如下：
            <ul>
              <li>
                @ or @attr - <br />
                绑定指令对应DOM元素属性值，该值必须是字符串。给定以下定义
                &lt;input type="text" ng-model="name" /&gt;
                &lt;widget my-attr="hello {{name}}"&gt; scope: { localName:'@myAttr' }，指令对应的html模板片段可以这样输出该值 {{localName}}。
                当my-attr属性变化时，localName值就会改变，但当localName值改变了，name对应的ng-model值不会改变<br />
                又如@形式：
                &lt;custom-directive demo-title="{{title}}" &gt; scope: { demoTitle: '@' }，这时指令对应的html模板片段可以这样输出该值 {{demoTitle}}。
              </li>
              <li>
                = or =attr - <br />
                设置一个本地的scope和父scope ng-model关联（会双向影响），例如
                &lt;input type="text" ng-model="parentModel" /&gt;
                &lt;widget my-attr="parentModel"&gt;  scope: { localModel :'=myAttr' }，指令对应的html模板片段可以这样输出该值 {{localModel}}。
                当parentModel的值改变了，localModel会改变，反之当localModel的值改变时，parentModel也会改变<br />
                又如 = 形式：
                &lt;custom-directive local-text="parentText" &gt; scope: { localText: '=' }，这时指令对应的html模板片段可以这样输出该值 {{localText}}。
                另外需要注意的是，如果父scope中没有定义相关的ng-model，指令中调用localText会出错，我们可以用=? 或=?attr来设置避免报错。
              </li>
              <li>
                &amp; or &amp;attr - <br />
                提供一个表达式并在父scope上下文中执行，如果不设置attr name，则表明scope中声明的变量名跟指令中属性名称是一样的。例如：
                &lt;widget my-attr="count = count + value"&gt;  scope: { localFn:'&amp;myAttr' }, 假如value在父scope的值为5，count为10，则执行后count的值就为15
              </li>
            </ul>
          </li>
          <li>controller<br />
            可以为该指令指定一controller，这样就允许指令间彼此通讯，该controller可以依赖注入以下service等
            <ul>
              <li>$scope - Current scope associated with the element</li>
              <li>$element - Current element</li>
              <li>$attrs - Current attributes object for the element</li>
              <li>$transclude - A transclude linking function pre-bound to the correct transclusion scope.   The scope can be overridden by an optional first argument.  function([scope], cloneLinkingFn).</li>
            </ul>
            <p>controller 会在 compile 函数之后， link 函数之前被执行。controller 的最后一个参数， $transclude ，是一个只接受 cloneAttachFn 作为参数的一个函数。</p>
            <p>下面的例子是指令中定义controller，并且设置其name别名，并结合require来引用</p>
            <pre>
     <div directive1 directive2>指令controller的设置，指令间利用controller的通讯</div>

     var directiveApp = angular.module('compileExample', []);
     directiveApp.directive('directive1', function(){
        return {
          name: 'directive1Name',
          restrict: 'EA',
          controller: function($scope, $element, $attrs, $transclude){
            console.log('directive1');
            this.text = '这是一个自定义的指令，别名为 directive1Name';
          },
          compile: function(){}
        };
      });
   
      directiveApp.directive('directive2', function(){
        return {
          restrict: 'EA',
          require: 'directive1Name',
          controller: function($scope, $element, $attrs, $transclude){
            console.log('directive2');
          },
          compile: function(){
            return function($scope, $element, $attrs, $controller){
              console.log($controller);
            };
          }
        };
      });
            </pre>
            <p>上面例子中directive2引用了directive1中定义的controller，所以directive2中的$controller就可以调用redirect1中controller设置的值了。注意这里是this.text设置。</p>
          </li>
          <li>require
            需要依赖其他指令
            require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
            例如ng-switch-when需要依赖 ng-switch <br />
            require设置的值可以带前缀 ^ 或 ?
            <ul>
              <li>不带前缀，如果找不到对应的controller，会报错</li>
              <li>^ 前缀，通过搜寻元素父节点来查找对应的controller，会报错</li>
              <li>? 前缀，如果找不到对应的controller，则会或略</li>
            </ul>
            <p>把controller中定义的例子如果改成 &lt;directive1&gt;&lt;directive2&gt;指令demo&lt;/directive2&gt;&lt;/directive1&gt; 我们就需要directive2这样设置了 require: '?^directive1Name'</p>
          </li>
          <li>restrict: 指令可以以哪些方式被使用，可以同时定义多种方式。
            <ul>
              <li>E 元素方式 &lt;my-directive&gt;&lt;/my-directive&gt;</li>
              <li>A 属性方式 &lt;div my-directive="exp"&gt; &lt;/div&gt;</li>
              <li>C 类方式 &lt;div class="my-directive: exp;"&gt;&lt;/div&gt;</li>
              <li>M 注释方式 &lt;!-- directive: my-directive exp --&gt;</li>
            </ul>
          </li>
          <li>template: 模板内容，可以包括变量引用的表达式。设置了改属性后，templateUrl将不起作用 </li>
          <li>templateUrl： 外部模板url，也可以是内部用script定义的模板。可以通过$sce.getTrustedResourceUrl.传入，具体如何使用待研究</li>
          <li>replace：是否使用模板内容替换掉整个节点， true 替换整个节点， false 替换节点内容。</li>
          <li>transclude：可以是true或 'element' 。
            true - transclude the content of the directive.
            'element' - transclude the whole element including any directives defined at lower priority. <br />
            如果不设置的话，不会处理指令中的内容或指令对应的dom，dom中包含的内容会根据controller所在的scope来处理
          </li>
          <li>compile: The compile function deals with transforming the template DOM. 用来编译模板内容 <br />
            <pre>
      compile: function compile(tElement, tAttrs, transclude) {
       return {
         pre: function preLink(scope, iElement, iAttrs, controller, transcludeFn) { ... },
         post: function postLink(scope, iElement, iAttrs, controller, transcludeFn) { ... }
       }
       // or
       // return function postLink( ... ) { ... }
     },
            </pre>
            <p>
              在指令层级嵌套的结构之下， postLink 是在所有的子级指令 link 完成之后才最后执行的。 compile 如果只返回一个函数，则这个函数被作为 postLink 使用
            </p>
            <pre>
      <div directive-parent>
        <directive-sub>
          compile pre 和 post例子
       </directive-sub>
      </div>
          
      directiveApp.directive('more2', function($rootScope, $document){
        return {
           restrict: 'EA',
           transclude: 'element', // element表示 transclude the whole element including any directives defined at lower priority.
           compile: function(element, attrs, link){
              var node = link($rootScope);
              node.removeAttr('more2'); //不去掉就变死循环了
              var $ = angular.element;
              $(document.body).append(node);
            }
        };
      });
      
      directiveApp.directive('showLength', function(){
         return {
           restrict: 'EA',
           transclude: true, // true表示只 transclude the content of the directive.
           compile: function(element, attrs, link){
            return function(scope, ielement, iattrs, controller){
              var node = link(scope);
              ielement.append(node);
              var $ = angular.element;
              var lnode = $('<div></div>');
              ielement.prepend(lnode);
              scope.$watch(function(scope){
                lnode.text(node.text().length);
              });
             };
            }
         };
       });
            </pre>
            <p>上面的例子在控制台输出的结果为：</p>
            <pre>
          directiveParent compile
          directiveSub compile
          directiveParent link pre
          directiveSub link pre
          directiveSub link post
          directiveParent link post
            </pre>
          </li>
          <li>link：This property is used only if the compile property is not defined.
            <pre>
            link: {
             pre: function preLink(scope, iElement, iAttrs, controller, transcludeFn) { ... },
             post: function postLink(scope, iElement, iAttrs, controller, transcludeFn) { ... }
            }
            or
            link: function postLink( ... ) { ... }
            </pre>
          </li>
        </ul>
        <p>下面是一个囊括directive定义时所有属性的<a href="./angular/examples/myExamples/directive-demo2.html">例子</a>，该例子中也包含了以下一些示例代码</p>

        <h5>$compile的理解</h5>
        <p>用法：    $compile(element, transclude, maxPriority); </p>
        <pre>
  var link = $compile('<p>{{text}}</p>');
  var node = link($scope);
  console.log(node);
        </pre>
        <p>调用$compile会返回一个link函数：function(scope[, cloneAttachFn])	，参数 cloneAttachFn 的作用是，表明是否复制原始节点，及对复制节点需要做的处理。
          cloneAttachFn的定义为：cloneAttachFn(clonedElement, scope)，
          clonedElement - is a clone of the original element passed into the compiler.
          scope - is the current scope with which the linking function is working with.
        </p>
        <p>$compile即可用在指令中，也可用在controller等中</p>
        <pre>
    <div ng-controller="CompileCtr"></div>
    <div id="tmpl">A {{text}}</div>
    <div id="content">B </div>
    var directiveApp = angular.module('compileExample', []);
      directiveApp.controller('CompileCtr', ['$scope','$compile', function($scope,$compile) {
        var $ = angular.element;//这里没有引入jQuery，直接用angular提供的
        var link = $compile(document.getElementById('tmpl'));
        //true参数表示新建一个完全隔离的scope,而不是继承的child scope
        var scope = $scope.$new(true);
        scope.text = '12345';
        var node = link(scope);
        $(document.getElementById('content')).append(node);
      }]);
        </pre>
        <p>cloneAttachFn 对节点的处理是有限制的，不能做与数据绑定有关的修改（修改了也无效）</p>
        <pre>
        var node = link(scope, function(clonedElement, scope){//is the current scope with which the linking function is working with.
          clonedElement.text(clonedElement.text() + ' ...'); //无效
          clonedElement.text('{{ text2}}'); //无效
          clonedElement.addClass('new_class');
          console.info(scope.text);
        });
        </pre>
        <p>修改无效的原因是，像 {{text}} 这种所谓的 Interpolate 在 $compile 中已经被处理过了，生成了相关函数（这里起作用的是 directive 中的一个 postLink 函数），后面执行 link 就是执行了 $compile 生成的这些函数。当然，如果你的文本没有数据变量的引用，那修改是会有效果的。

          前面在说自定义指令时说过， link 函数是由 compile 函数返回的，也就像前面说的，应该把改变 DOM 结构的逻辑放在 compile 函数中做。</p>
        <p>
          $compile 共有三个参数，$compile(element, transclude, maxPriority); element是字符串或DOM，
          transclude是一个有效的函数，他会传递给 compile 期间找到的 directive 的 compile 函数（编译节点的过程中找到了指令，指令的 compile 函数会接受编译时传递的 transclude 函数作为其参数）。
          但是在实际使用中，除我们手工在调用 $compile 之外，初始化时的根节点 compile 是不会传递这个参数的。
          在我们定义指令时，它的 compile 函数是这个样子的：function compile(tElement, tAttrs, transclude) { ... }
        </p>
        <p>事实上， transclude 的值，就是 directive 所在的 原始 节点，把原始节点重新做了编译之后得到的 link 函数（需要 directive 定义时使用 transclude 选项），
          。所以，官方文档上也把 transclude 函数描述成 link 函数的样子（如果自定义的指令只用在自己手动 $compile 的环境中，那这个函数的形式是可以随意的）。
          所以记住，定义指令时， compile 函数的第三个参数 transclude ，就是一个 link ，装入 scope 执行它你就得到了一个节点。</p>

        <h5>transclude的细节</h5>
        <p>transclude 有两方面的东西，一个是使用 $compile 时传入的函数，另一个是定义指令的 compile 函数时接受的一个参数。
          虽然这里的一出一进本来是相互对应的，但是实际使用中，因为大部分时候不会手动调用 $compile ，
          所以，在“默认”情况下，指令接受的 transclude 又会是一个比较特殊的函数。</p>
        <p>看下面的例子</p>
        <pre>
     //directiveApp同上面的定义
     directiveApp.directive('more', function(){
        return {
           restrict: 'EA',
           compile: function(element, attrs, transclude){
              var sum = transclude(1, 2);
              console.log(sum);
              console.log(element);  
            }
        };
      });

      directiveApp.controller('CompileCtr2', function($scope, $compile, $element){
        var text = '<more>123</more>';
        var link = $compile(text, function(a, b){
          return a + b;
        });
        var node = link($scope);
        $element.append(node);
      });
        </pre>
        <p>
          我们定义了一个 more 指令，它的 compile 函数的第三个参数，就是我们手工 $compile 时传入的。
          如果不是手工 $compile ，而是 ng 初始化时找到的指令，则 transclude 是一个 link 函数（指令定义需要设置 transclude 选项）。看如下例子：
        </p>
        <pre>
    directiveApp.directive('more2', function($rootScope, $document){
        return {
           restrict: 'EA',
           transclude: 'element', // element是节点,其它值是节点的内容
           compile: function(element, attrs, link){
              var node = link($rootScope);
              node.removeAttr('more2'); //不去掉就变死循环了
              var $ = angular.element;
              $(document.body).append(node);
            }
        };
      });
        </pre>

        <h5>指令处理节点是变量的情况</h5>
        <p>这点很重要，可以在不引入模板的情况下，简单的处理节点内容，我们还是以例子来分析吧</p>

        <pre>
    <div ng-controller="CompileCtr" ng-init="text = '点击计算长度'; ">
      <div show-length>{{text}}</div>
      <button ng-click="text = '改变后的长度'">改变</button>
    </div>
    
    var directiveApp = angular.module('compileExample', []).controller('CompileCtr', function($scope, $compile, $element){
      });
    directiveApp.directive('showLength', function(){
      return {
        restrict: 'EA',
        transclude: true, // true表示只 transclude the content of the directive.
        compile: function(element, attrs, link){
         return function(scope, ielement, iattrs, controller){
           var node = link(scope);
           ielement.append(node);
           var $ = angular.element;
           var lnode = $('<div></div>');
           ielement.prepend(lnode);
           scope.$watch(function(scope){
             lnode.text(node.text().length);
           });
          };
         }
      };
        </pre>
        <p>上面例子中指令如果不设置 transclude 属性，并且把compile函数中的内容注释掉，则show-length中会输出内容；如果设置了transclude，就需要compile中link函数来处理，所以当注释了compile后，show-length中不会显示内容。</p>
        <p>我们看看angular是怎么解析这条指令的</p>
        <ul>
          <li>在 $compile(element)($rootScope);时，angular找到了show-length的指令。</li>
          <li>如果 show-length 指令设置了 transclude 属性，则 div 的节点内容被重新编译，得到的 link 函数（publicLinkFn(scope, cloneConnectFn, transcludeControllers)）作为指令 compile 函数的参数传入。</li>
          <li>如果 show-length 指令没有设置 transclude 属性，则继续处理它的子节点（TextNode ）。</li>
          <li>不管是上面的哪种情况，都会继续处理到 {{text}} 这段文本。</li>
          <li>发现 {{text}} 是一个 Interpolate ，于是自动在此节点中添加了一个指令，这个指令的 link 函数就是为 scope 添加了一个 $watch ，
            实现的功能是当scope 作 $digest 的时候，就更新节点文本。</li>
        </ul>
        <p>与处理 {{text}} 时添加的指令相同，我们实现 showLength 的思路，也就是：</p>
        <ul>
          <li>修改原来的 DOM 结构</li>
          <li>为 scope 添加 $watch ，当 $digest 时修改指定节点的文本，其值为指定节点文本的长度。</li>
        </ul>
        <p>以上的解释参考网络，有待确认</p>

        <h5>指令中对应节点属性的处理</h5>
        <p>angular针对节点属性的处理专门定义了一个对象</p>
        <pre>
    var Attributes = function(element, attr) {
      this.$$element = element;//属性所在的节点
      this.$attr = attr || {};//所有的属性值（key-value object）
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,//处理指令名称，把指令名称转换为驼峰式名称
      $addClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.addClass(this.$$element, classVal);
        }
      },
      $removeClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.removeClass(this.$$element, classVal);
        }
      },
      //设置对象属性，及节点属性
      $set: function(key, value, writeAttr, attrName) {},
      //为属性注册侦听函数
      $observe: function(key, fn) {}
    };
        </pre>
        <p>除了以上代码中定义的，还包括元素所有属性名和值，如： attr['attrName'] = 'attrValue'; </p>

        <p>我们看一下$observe的用法</p>
        <pre>
     <div ng-controller="DirectiveCtr">
      <directive-attr-demo attr1="{{ attrVar}}" attr2 attr3="world"></directive-attr-demo>
      <button ng-click="attrVar = attrVar + ',World'">修改</button>
    </div>

      var directiveApp = angular.module('directiveAttrExample', []);
      directiveApp.controller('DirectiveCtr', ['$scope', function($scope) {
         $scope.attrVar = 'Hello';
      }]);
      
      directiveApp.directive('directiveAttrDemo', function(){
        return {
          restrict: 'EA',
          link: function($scope, $element, $attrs){
            console.info($attrs);
            
            $attrs.$observe('attr1',function(newValue, oldValue){
              console.info('attr1 oldValue: ' + oldValue);
              console.info('attr1 newValue: ' + newValue);
            });
            //$watch是用来监听变量的
            $scope.$watch('attrVar',function(newValue, oldValue){
              console.info('attrVar oldValue: ' + oldValue);
              console.info('attrVar newValue: ' + newValue);
            });
          }
        };
      });
        </pre>

        <p>上面的例子可以看出 $observe是用来监听属性的，而 $scope 中的 $watch是用来监听变量的。在实际开发中，利用$observe可以很方便的实现业务功能。 </p>

        <p>方法$addClass和$removeClass是新加的，主要用来实现动画</p>
        <p>方法$set的用法：function(key, value, writeAttr, attrName) { ... }</p>
        <ul>
          <li><em>key</em> $attrs 对象成员名(指变量名，不是属性名，如下面例子，第一条语句，实际属性名是 attr-demo1)。</li>
          <li><em>value</em> 设置的值。</li>
          <li><em>writeAttr</em> 是否同时修改 DOM 节点的属性值，默认为true。</li>
          <li><em>attrName</em> 实际的属性名，如不设置属性名为key(需转换为属性名)</li>
        </ul>
        <pre>
        $attrs.$set('attrDemo1', 'attrDemo1');
        $attrs.$set('attr-demo2', 'attr-demo2');
        $attrs.$set('attr-demo3', 'attr-demo3', false);
        $attrs.$set('attrDemo4', 'attr-demo4', true, 'attr_demo4');
        </pre>

        <h4>$rootScope 与 $scope</h4>
        <p>
          每一个application model 都有一个唯一的root scope，在app下面所有的child scope都会继承root scope。
          Scopes provide separation between the model and the view
        </p>
        <ul>
          <li>scope提供了$watch来监听model的变化</li>
          <li>Scopes provide APIs ($apply) to propagate any model changes through the system into the view from outside of the "Angular realm" (controllers, services, Angular event handlers).</li>
          <li>Scopes can be nested to isolate application components while providing access to shared model properties. A scope (prototypically) inherits properties from its parent scope.</li>
        </ul>

        <h5>Scope Hierarchies</h5>
        <p>scope 就像DOM节点，是有层级的，每个 child scope继承 parent scope。
          比如Angular 处理{{name}}时，首先在当前scope查找，如果没有找到，会在他的 parent scope查找，直到 root scope。</p>
        <h5>Scope Events Propagation</h5>
        <p>scope event可以实现事件向上或向下传播，是通过调用$emit 和 $broadcast （The event can be broadcasted to the scope children or emitted to scope parents.）。看下面的例子：</p>
        <pre>
&lt;!DOCTYPE html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;compile demo&lt;/title&gt;
    &lt;link rel="stylesheet" href="../../../../../platform/css/bootstrap/css/bootstrap.css" type="text/css"/&gt;
    &lt;style type="text/css"&gt;
      body{
        padding: 10px;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div ng-controller="EventController"&gt;
      Root scope &lt;tt&gt;MyEvent&lt;/tt&gt; count: {{count}}
      &lt;ul&gt;
        &lt;li ng-repeat="i in [1]" ng-controller="EventController"&gt;
          &lt;button ng-click="$emit('MyEvent')"&gt;$emit('MyEvent')&lt;/button&gt;
          &lt;button ng-click="$broadcast('MyEvent')"&gt;$broadcast('MyEvent')&lt;/button&gt;
          &lt;br&gt;
          Middle scope &lt;tt&gt;MyEvent&lt;/tt&gt; count: {{count}}
        &lt;ul&gt;
          &lt;li ng-repeat="item in [1, 2]" ng-controller="EventController"&gt;
            Leaf scope &lt;tt&gt;MyEvent&lt;/tt&gt; count: {{count}}
          &lt;/li&gt;
        &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script type="text/javascript" src="../../angular.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        function EventController($scope) {
          $scope.count = 0;
          $scope.$on('MyEvent', function() {
            $scope.count++;
          });
        }
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
        </pre>

        <p><a href="./angular/examples/myExamples/scope-events-propagation.html">例子</a></p>
        <h5>$rootScope method</h5>
        <p>$rootScope 和 $scope 内部实现是通过function $RootScopeProvider来实现的</p>
        <ul>
          <li>$apply(exp)：用来执行表达式，并且使其内部具有生命周期，内部对于生命周期的处理时比较发展的，详见代码实现。</li>
          <li>$broadcast(name, args)：用来事件向下传播，这里的事件是指通过$on注册的。name事件名，args是指事件监听的参数</li>
          <li>$emit(name, args)：与$broadcast对应，事件向上传播</li>
          <li>$destroy()：销毁current scope以及 child scope</li>
          <li>$digest()：来处理监听函数的，用来轮循监听函数，直至都触发完，但轮循不能超过最大值，'Maximum iteration limit exceeded.' if the number of iterations exceeds 10.
            通常我们是不需要调用该方法的，交给$apply即可，他会处理的</li>
          <li>$eval(expression, locals)：在当前scope中执行表达式，比如scope.$eval('a+b')或scope.$eval(function(scope){ return scope.a + scope.b; }) 如果我们定义scope.a=1;scope.b=2; 则执行结果为3</li>
          <li>$evalAsync(expression)：延迟执行表达式</li>
          <li>$new(isolate)：创建新的scope</li>
          <li>$on(name, listener)：注册监听函数</li>
          <li>$watch(watchExpression, listener, objectEquality)：添加watchExpression的监听，当watchExpression改变时，触发listener。
            当调用$digest() 时，当watchExpression改变了，才会触发listener，不是所有的监听表达式都会触发
          </li>
          <li>$watchCollection(obj, listener)：obj是array的监听，例子：
            $scope.names = ['igor', 'matias', 'misko', 'james']; <br />
            $scope.dataCount = 4;<br />
            $scope.$watchCollection('names', function(newNames, oldNames) {<br />
            $scope.dataCount = newNames.length;<br />
            });</li>
        </ul>

        <h4>Angular 源码分析</h4>
        <h5>Angular代码结构与加载过程</h5>
        <p>先看一下代码结构</p>
        <pre>
(function(window, document, undefined) {
  
  //设置严格模式，解析和加载更快，你懂得
  'use strict';
  //try to bind to jquery now so that one can write angular.element().read()
  //but we will rebind on bootstrap again.
  //尝试绑定jQuery对象
  bindJQuery();
 
  //初始化angular环境，扩展API
  publishExternalAPI(angular);
  
  jqLite(document).ready(function() {
    //当页面加载完后，初始化angular，bootstrap是定义的一个函数，用来解析，编译angular相关行为：指令等
    angularInit(document, bootstrap);
  });

})(window, document);
        </pre>
        <p>首先会尝试绑定jQuery，如果没有提供，用angular自己的 JQLite；然后初始化angular环境，主要扩展API、绑定系统定义的指令、用$provide.provider初始化服务等；
          最后就是解析加载DOM，见方法angularInit(document, bootstrap); 该方法中会判断页面是否定义了ng-app指令，如没有是不会解析加载的（可以手工调用方法 bootstrap 加载）。
          加载过程内部处理比较复杂，主要是按照DOM结构，从定义ng-app开始依次遍历所有的节点，并处理节点中定义的指令，期间会处理view和scope数据的关联等。
          可以看出，Angular对于document的处理主要包括初始化和解析加载DOM两部分。
        </p>

        <h5>Angular 几个比较重要的属性和方法</h5>
        <ol>
          <li>
            annotate(fn)：内部方法，用来返回fn参数名称，返回的结果是数组，例如：<br />
            ["$provide", ngModule(provide)]返回["$provide"]；ngModule($provide)返回["$provide"]
          </li>
          <li>
            createInjector(modulesToLoad)：根据module创建 injector，返回的结果为
            <pre>
    annotate: annotate(fn)
    get: getService(serviceName)
    has: function()
    instantiate: instantiate(Type, locals)
    invoke: invoke(fn, self, locals)
            </pre>
            <p>封装了以上四个内部函数，在createInjector中也实现了provider和injector的关联</p>
          </li>
          <li>
            $CompileProvider，该方法是编译，提供者，主要用来注册指令，编译解析指令等
          </li>
          <li>$injector <br />
            该方法是用来实例化已经注入的参数对象，是通过provider来实例的。实例对象，调用方法，加载modules
          </li>
          <li>
            $compile：用来编译指令的
          </li>
          <li>
            $parse: 根据指令名返回该指令对应的函数fn，例如 ng-click="clickBtn();"，调用$parse('ng-click');后则返回clickBtn
          </li>
        </ol>

        <h4>学习angular技巧与方法（最佳实践）</h4>
        <h5>在终端控制台调试</h5>
        <p>先看一例子</p>
        <pre>
  &lt;p id="test" ng-controller="TestCtrl"&gt;{{ a}}&lt;/p&gt;
  
  &lt;script type="text/javascript"&gt;
  var TestCtrl = function($scope){
    $scope.a = '123';
  }
  angular.bootstrap(document.documentElement);
  &lt;script&gt;
        </pre>
        <p>我们可以在控制台输入以下代码来测试(需要导入jquery)</p>
        <pre>
  $('#test').scope().a = '12345';
  $('#test').scope().$digest();
        </pre>

        <h5>数据绑定标识标签的修改</h5>
        <p>Angular提供的默认为 {{}} ，如果与其他框架有冲突的话，我们可以调用以下代码来修改</p>
        <pre>
  var customInterpolationApp = angular.module('customInterpolationApp', []);
  customInterpolationApp.config(function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });
        </pre>

        <h5>依赖注入的写法</h5>
        <p>在Angular中，可以直接在函数参数中注入，也可以通过数组（字符串）注入，这两种都会通过内部函数annotate(fn)来处理的。结果会返回依赖函数对应字符串组成的数组</p>
        <pre>
    var myApp = angular.module('myApp',[]);
    //通过数组（字符串）注入
    myApp.controller('GreetingCtrl', ['$scope', function($scope) {
      $scope.greeting = 'Hola!';
    }]);
    //直接用参数来注入，
    myApp.controller('GreetingCtrl', function($scope) {
      $scope.greeting = 'Hola!';
    });
        </pre>
        <p>上面的代码都可以注入$scope，但第二种方式当js被压缩时，参数名可能就会变成其他的名称，导致运行解析时不能找到注入的$scope，所以推荐用第一种方式书写。</p>
        <p>当然我们也可以使用 $inject 来注入，实际上当为函数指定了属性 $inject，在annotate(fn)中将直接返回，没有指定的话，会为fn赋值属性 $inject</p>
        <pre>
    var MyController = function(obfuscatedScope, obfuscatedRoute) {
    MyController.$inject = ['$scope', '$route'];
        </pre>

        <h5>关于登录页面自动保存密码的问题</h5>
        <p>问题：在登录页面中，浏览器会提示是否保存密码，如果选择了是，则下次登录时，将不用输入密码。如果angular是利用ng-model来获取密码时，由于没有触发chang事件，实际ng-model中对应的密码变量是没有值的。</p>
        <p>解决方法：提交时，不从ng-model变量中取值，直接从input password中取。代码实现</p>

        <pre>
    $scope.user = {
      username: '',
      password: '',
      // other property
    };
    //错误的写法
    $scope.submit = function() {     
      loginService.login($scope.user, function(data) {
         //....
      });
    };
    //正确的写法
    $scope.submit = function() {    
      $scope.user.username = $("#username").val();  
      $scope.user.password = $("#password").val();     
      loginService.login($scope.user, function(data) {
         //....
      });
    };       
        </pre>
      </div>

      <h3 paragraph>Angular 关于浏览器的兼容性</h3>
      <div>
        <p>这里说的兼容性主要是指IE，官方推荐的最低版本是IE8，不过如果我们想要在ie6和ie7下运行angular，我们可以按照以下步骤来处理（本人只测试了IE7）。</p>
        <ol>
          <li>我们首先需要引入<a href="https://github.com/douglascrockford/JSON-js">JSON2</a>或<a href="http://bestiejs.github.com/json3/">JSON3</a>
            <pre>
    &lt;!doctype html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;!--[if lte IE 8]&gt;
          &lt;script src="json2.js"&gt;&lt;/script&gt;
        &lt;![endif]--&gt;
      &lt;/head&gt;
      &lt;body&gt;
      ...
      &lt;/body&gt;
    &lt;/html&gt;
            </pre>
          </li>
          <li>
            在加入指令ng-app的DOM元素（一般是html）中加入id属性， id="ng-app" 
            <pre>
    &lt;!doctype html&gt;
    &lt;html id="ng-app" ng-app="optionalModuleName"&gt;
    ...
    &lt;/html&gt;
            </pre>
          </li>
          <li>
            我们尽量用属性的方法书写指令，比如 &lt;ng:view&gt; 可以用 &lt;div ng-view&gt; 代替。如果我们想要用自定义标签时，我们需要为ie7单独的处理
            <pre>
    &lt;!doctype html&gt;
    &lt;html id="ng-app" ng-app="optionalModuleName"&gt;
      &lt;head&gt;
      &lt;!--[if lte IE 8]&gt;
        &lt;script&gt;
          document.createElement('ng-include');
          document.createElement('ng-pluralize');
          document.createElement('ng-view');

          // Optionally these for CSS
          document.createElement('ng:include');
          document.createElement('ng:pluralize');
          document.createElement('ng:view');
        &lt;/script&gt;
      &lt;![endif]--&gt;
      &lt;/head&gt;
      &lt;body&gt;
      ...
      &lt;/body&gt;
    &lt;/html&gt;
            </pre>
            <p>这些声明必须写在页面的最上面</p>
          </li>
          <li>
            对于自定义标签，我们需要为其设置默认css样式，设置样式之前确保调用了document.createElement('custom-tag');
            <pre>
    &lt;html&gt;
      &lt;head&gt;
      &lt;!--[if lte IE 8]&gt;
        &lt;script&gt;
          // needed to make ng-include parse properly
          document.createElement('ng-include');

          // needed to enable CSS reference
          document.createElement('ng:view');
        &lt;/script&gt;
      &lt;![endif]--&gt;
      &lt;style&gt;
        ng\:view {
          display: block;
          border: 1px solid red;
        }

        ng-include {
          display: block;
          border: 1px solid blue;
        }
      &lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;ng:view&gt;&lt;/ng:view&gt;
        &lt;ng-include&gt;&lt;/ng-include&gt;
        ...
      &lt;/body&gt;
    &lt;/html&gt;
            </pre>
          </li>
          <li>为了支持html5和css3，我们需要引入html5shiv.js 和 respond.js。html5shiv.js是用来解析html5的，respond.js是用来处理css3的（包括响应式布局等）</li>
          <pre>
      &lt;!--[if lt IE 9]&gt;
        &lt;script src="html5shiv.min.js"&gt;&lt;/script&gt;
        &lt;script src="respond.min.js"&gt;&lt;/script&gt;
      &lt;![endif]--&gt;
          </pre>
        </ol>

        <p>下面给出一个在ie6，ie7下兼容性的例子</p>

        <p><a href="./angular/examples/myExamples/IE-compatibility-demo.html">例子</a></p>

      </div>

    </div>
  </body>
</html>